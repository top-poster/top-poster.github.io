---
layout: post
title: "JavaScript 프록시에 대해 알아야 할 모든 사항"
author: "Logger"
thumbnail: "undefined"
tags: 
---


![Image for post](https://miro.medium.com/max/5696/1*XTOKpftxWoDXQbDvWW6ybQ.jpeg)

먼저 해야 할 일: MDN의 프록시 공식 정의는 다음과 같다.

이제 좀 더 깊이 파고들기 전에 먼저 실제 사례를 몇 가지 논의해보고 마지막에 프록시에 대한 명료성을 높일 수 있도록 하자. 그의 글에서 비트피쉬는 이렇게 설명했다.

우리는 인간으로서 이메일 읽기, 배달 받기 등 일상 생활에서 해야 할 일이 많다. 때때로, 우리는 많은 추가적이고 불필요한 작업들 때문에 약간 불안함을 느낄 수 있습니다. 예를 들어, 스팸 메일이 많고 그것들을 제거하는 데 약간의 노력과 시간이 걸리며, 또는 받은 배달에 테러리스트들이 심은 폭탄이 포함되어 우리의 안보를 위협할 수도 있습니다.

누군가 당신을 이런 위협으로부터 보호해주길 바라는 곳이죠. 충성스런 가정부죠. 우리는 우리가 하고 있는 일을 지켜줄 여분의 무언가를 해줄 누군가가 필요하다.

이제 기본 사항인 JavaScript로 돌아가 보겠습니다. 우리는 캡슐화, 추상화, 클래스, 객체 등과 같은 객체 지향 프로그래밍 패러다임이 제공하는 기능을 사용하도록 JavaScript를 확장할 수 있다는 것을 알고 있다. 모든 JavaScript 개발자는 개체를 사용하고 일부 정보를 개체에 저장하는 것이 매우 일반적이라고 할 수 있습니다.

하지만 이렇게 하면(물건을 사용) 코드가 안전하지 않게 됩니다. 왜냐하면 JavaScript 개체는 항상 맨몸으로 실행되며 이러한 개체로 모든 작업을 수행할 수 있기 때문입니다.

그래서 이 문제를 해결하기 위해, Proxy라는 새로운 기능이 흔히 ES6로 알려진 ECMA스크립트 2015에 도입되었다. Proxy를 사용하면 개체에 대한 충실한 가정부를 찾을 수 있으며 개체의 원래 기능을 향상시킬 수 있습니다.

# JavaScript 프록시 개체란?

개인적으로는 메일 읽기, 배달 받기 등의 작업이 있을 수 있고, 가정부가 대신 해줄 수 있습니다. 개체의 기본 작업은 속성 조회, 할당, 열거 및 함수 호출 등이 될 수 있으며 프록시 개체에 의해 향상될 수도 있습니다.

![Image for post](https://miro.medium.com/max/1160/0*Ug6NnJW_8IfNHBAK.png)

## 프록시 개체 생성

기본적으로 다음 구문을 사용하여 `프록시`를 만들 수 있습니다.

```js
프록시 = 새 프록시(대상, 핸들러)로 설정합니다.
```

어디에

Proxy는 모든 작업을 처리기 개체로 리디렉션하는 대상 개체 주위에 탐지할 수 없는 장벽을 만듭니다. 빈 핸들러를 보내면 프록시는 원래 개체를 감싸는 빈 포장지일 뿐입니다.

## 단순 프록시 예제

먼저 `user`라는 새로운 개체를 정의해 봅시다.

```js
constuser = {
이름: '존',
성: 'Doe',
이메일: 'john.doe@example.com',
}
```

이제 `핸들러` 개체를 정의합니다.

```js
const 핸들러 = {
get(항목, 속성, itemProxy) {
console.log('속성 ${property})'를 읽었습니다.`);
목표[재산]를 반환하다
}
}
```

get 함수는 다음 세 가지 인수를 사용할 수 있습니다.

이제 `프록시` 개체를 만들 수 있습니다. 이렇게 하면 매우 간단합니다.

```js
constroxyUser = 새 프록시(사용자, 핸들러);
```

`proxyUser` 개체는 `user` 개체를 사용하여 데이터를 저장합니다. `proxyUser`는 `user` 개체의 모든 속성에 액세스할 수 있습니다.

![Image for post](https://miro.medium.com/max/1290/0*0hxLkzpYEuuK68cY.png)

이제 `proxyUser` 개체를 통해 `user` 개체의 `firstName` 및 `lastName` 속성에 액세스해 보겠습니다.

```js
console.log(proxyUser.firstName);
console.log(proxyUser.lastName);
```

출력은 다음과 같습니다.

```js
속성 firstName을(를) 읽었습니다.
존
속성 lastName을(를) 읽었습니다.
도
```

위의 예에서 get 함수의 반환 값은 이 속성을 읽은 결과입니다. 우리는 아직 아무것도 바꾸고 싶지 않기 때문에, 원래 객체의 부동산 가치를 반환할 뿐입니다.

필요하다면 결과도 바꿀 수 있습니다. 예를 들어 다음과 같은 작업을 수행할 수 있습니다.

```js
obj = {a:1, b:2}을(를) 사용하도록 합니다.
처리기 = {} 허용
get: 함수(항목, 속성, itemProxy){
console.log('${property}' 속성 값을 가져오고 있습니다.')
반품 품목[재산] * 2
}
}
objProxy = 새 프록시(obj, 처리기)를 사용하도록 설정합니다.
console.log(objProxy.a)
console.log(objProxy.b)
```

출력은 다음과 같습니다.

```js
'a' 속성의 값을 얻고 있습니다.
2
'b' 속성 값을 얻고 있습니다.
4
```

# 프록시 트랩

## get() 덫

get() 트랩은 프록시 개체를 통해 대상 개체의 속성에 액세스할 때 발생합니다.

앞의 예에서는 `user` 개체의 속성이 `proxyUser` 개체에 의해 액세스되면 메시지가 출력됩니다.

## 세트() 트랩

속성에 대한 읽기를 가로채는 것 외에 속성에 대한 수정도 가로챌 수 있다. 다음과 같은 경우:

```js
obj = {a:1, b:2}을(를) 사용하도록 합니다.
처리기 = {} 허용
set: 함수(항목, 속성, 값, itemProxy){
console.log('${value}'를 '${property}' 속성'으로 설정하고 있습니다.)
항목[속성] = 값
}
}
objProxy = 새 프록시(obj, 처리기)를 사용하도록 설정합니다.
```

이제 속성 값을 업데이트하면 다음과 같은 출력이 표시됩니다.

![Image for post](https://miro.medium.com/max/1190/1*SChCEmf3cgXk3CHSz_NCbQ.png)

속성 값을 설정할 때 추가 값을 전달해야 하기 때문에 위의 집합 함수는 get 함수보다 한 개의 인수를 더 많이 사용합니다.

Proxy는 읽기 및 속성 수정 외에도 개체에 대한 총 13개의 작업/트랩을 인터셉트할 수 있습니다.

그 이유는 다음과 같습니다.

대상 개체가 함수인 경우 인터셉트할 두 가지 추가 작업이 있습니다.

이제 몇 가지 사용 사례에 대해 살펴보고 프록시가 실제로 우리에게 어떤 도움을 줄 수 있는지 알아보겠습니다. 다음은 프록시가 구세주가 될 수 있는 그의 기사에서 비트피쉬가 공유한 사용 사례이다.

# 배열의 음수 인덱스 구현

파이썬과 같은 프로그래밍 언어 중 일부는 배열에서 음의 인덱스를 지원한다.

음수 인덱스는 배열의 마지막 위치를 시작점으로 삼고 앞으로 카운트합니다. 다음과 같은 경우:

이렇게 하면 다음과 같이 정의되지 않습니다.

![Image for post](https://miro.medium.com/max/1014/1*zgBp4R9hkAU1afonU9yBrQ.png)

어레이를 Proxy 개체로 포장할 수 있습니다. 사용자가 음의 인덱스에 액세스하려고 할 때 프록시의 가져오기 방법을 통해 이 작업을 가로챌 수 있습니다. 음수 인덱스는 이전에 정의한 규칙에 따라 양수 인덱스로 변환되고 액세스가 완료됩니다.

Proxy를 사용하여 이 문제를 정확히 어떻게 달성할 수 있는지 알아보겠습니다.

따라서 사용자가 배열의 인덱스인 속성에 액세스하려고 할 때 음의 인덱스로 판명되면 이를 인터셉트하고 그에 따라 처리해야 합니다. 속성이 인덱스가 아니거나 인덱스가 양수이면 아무 작업도 수행하지 않습니다.

먼저 Proxy의 get 메서드는 배열 인덱스에 대한 액세스와 배열의 다른 속성에 대한 액세스를 포함하여 배열의 모든 속성에 대한 액세스를 차단합니다. 배열의 요소에 액세스하는 작업은 속성 이름을 정수로 변환할 수 있는 경우에만 수행됩니다. 어레이의 요소에 액세스하려면 이 작업을 인터셉트해야 합니다.

우리는 배열의 속성이 인덱스인지 여부를 정수로 변환할 수 있는지 확인하여 확인할 수 있습니다.

```js
번호(propKey)!= NaN
```

전체 코드는 다음과 같습니다.

```js
함수 음수 어레이(어레이) {
새 프록시(어레이, {}) 반환
get: 함수(대상, propKey){
if (숫자(propKey)!= NaN
```

Chrome의 Developer Tool에서 예를 들어 보겠습니다.

![Image for post](https://miro.medium.com/max/1588/1*RGtmiFSUQp0SfWRrSUz92w.png)

# 데이터 유효성 검사

우리가 알고 있듯이, javascript는 약하게 타이핑된 언어이다. 일반적으로 개체가 생성되면 맨몸으로 실행됩니다. 누구나 수정할 수 있습니다.

그러나 대부분의 경우 특정 조건을 충족하려면 개체의 속성 값이 필요합니다. 예를 들어 사용자 정보를 기록하는 개체는 연령 필드에서 0보다 큰 정수(일반적으로 150보다 작은 정수)를 가져야 한다.

```js
사용자 1 = {}을(으)로 설정
이름: '존',
연령: 23세
}
```

그러나 기본적으로 JavaScript는 보안 메커니즘을 제공하지 않으며 사용자가 원하는 대로 이 값을 변경할 수 있습니다.

```js
Person 1.나이 = 9999
Person 1.age = 'hello world'
```

코드를 보다 안전하게 만들기 위해 Proxy로 개체를 포장할 수 있습니다. 개체의 설정 작업을 인터셉트하고 연령 필드의 새 값이 규칙을 준수하는지 확인할 수 있습니다.

코드로 정확하게 수행할 수 있는 방법은 다음과 같습니다.

```js
letageValidate = {}
설정(항목, 속성, 값) {
(속성 === '나이') {
if (!Number. is Integer(값) || 값 < 0 || 값 > 150) {
새 유형 오류 던지기('age는 0에서 150 사이의 정수여야 함;
}
}
항목[속성] = 값
}
}
```

이제 우리는 이 속성의 값을 수정하려고 합니다. 그리고 우리가 설정한 보호 메커니즘이 작동하고 있다는 것을 알 수 있습니다.

![Image for post](https://miro.medium.com/max/1592/1*8Wuen4R6sNjV53j1WwEFQQ.png)

# 속성 연결

많은 경우 개체의 속성은 서로 관련되어 있습니다. 예를 들어, 사용자 정보를 저장하는 개체의 우편 번호와 위치는 고도로 상관된 두 가지 속성입니다. 사용자의 우편번호가 결정되면 사용자의 위치도 결정됩니다.

다른 나라의 독자들을 수용하기 위해, 저는 여기서 가상의 예를 사용합니다. 위치 및 우편번호가 다음과 같은 관계가 있다고 가정합니다.

```js
자바스크립트 스트리트 - 232200
파이톤 스트리트 - 234422
골랑거리 - 231142
```

이것은 그들의 관계를 코드로 표현한 결과입니다.

```js
구성 2 우편 번호 = {
자바스크립트 스트리트: 232200,
'파이튼 스트리트': 234422,
'골랑거리': 231142
}
구성 포스트코드2 위치 = {
'232200': 'JavaScript Street',
'234422': '피톤 스트리트'
'231142': '골랑가'
}
```

그런 다음 예를 살펴봅니다.

```js
개인 = {}을(를) 허용합니다.
이름: '존',
}
Person.우편번호 = 232200
```

우리는 `person.postcode=232200`을 설정할 때 `person.location=`JavaScript Street`를 자동으로 트리거할 수 있기를 원합니다.

해결 방법은 다음과 같습니다.

```js
let postcodeValidate = {}
설정(항목, 속성, 값) {
if(속성 === 'location') {
품목의우편번호 = 위치2 우편번호[값]

}
if(속성 === 'postcode'){
item.location = postcode2 location[값]
}
}
}
```

![Image for post](https://miro.medium.com/max/1762/1*uQ5YsdQ4ViiIsduqhs1CVQ.png)

그래서 우리는 `우편번호`와 `위치`를 함께 묶었다.

# 사유 재산

우리는 자바스크립트에서 개인 속성이 지원되는 적이 없다는 것을 알고 있다. 이것은 우리가 코드를 작성할 때 접근 권한을 합리적으로 관리하는 것을 불가능하게 합니다.

이 문제를 해결하기 위해 자바스크립트 커뮤니티의 관습은 문자 `_`로 시작하는 필드를 개인 속성으로 간주한다는 것이다.

```js
varob = {
a: 1,
_값: 22
}
```

위의 `_value` 속성은 비공개로 간주됩니다. 그러나 중요한 것은 이것은 관습일 뿐 언어 수준에는 그러한 규칙이 없다는 것이다.

프록시를 사용하므로 개인 속성 기능을 시뮬레이션할 수 있습니다.

일반 속성과 비교하여 개인 속성의 특징은 다음과 같습니다.

그런 다음 앞에서 언급한 Proxy의 13개 인터셉트 작업을 검사하여 인터셉트해야 하는 작업이 3개 있음을 확인할 수 있습니다.

```js
함수 setPrivateField(obj, 접두사 = "_"){
새 프록시(obj, {}) 반환
// objProxy의 'propKey' 작업 가로채기
have: (obj, prop) => {},
// 'Object.keys(proxy)'와 같은 작업 가로채기`
자체 키: obj = > {},
//개체 속성의 읽기 작업 중단
get: (obj, prop, rec) => {}
});
}
```

그런 다음 템플릿에 적절한 판단 문을 추가한다. 사용자가 `_misc 액세스`로 시작하는 필드에 액세스하려고 하면 액세스가 거부된다.

```js
함수 setPrivateField(obj, 접두사 = "_"){
새 프록시(obj, {}) 반환
have: (obj, prop) => {.
if(prop === "string" 유형)
```

다음은 예제의 마지막 코드입니다.

![Image for post](https://miro.medium.com/max/1922/1*ioR8JLrA0E8bhVIVGA89iA.png)

# 결론

우리는 자바스크립트에서 정확히 `프록시`가 무엇인지, 그것의 사용 사례는 무엇인지 알게 되었다. 우리는 이제 어떻게 우리가 사물을 정찰하기 위해 프록시를 사용할 수 있는지 안다. 이제 처리기 개체의 트랩 방법을 사용하여 동작을 추가할 수 있습니다. 이제 자바스크립트에서 `프록시`로 가능성을 탐색할 수 있는 충분한 영감을 얻으셨기를 바랍니다.

읽어주셔서 감사합니다. 이 기사가 당신에게 도움이 되었기를 바랍니다. 질문이나 건의사항을 답변해 주시기 바랍니다.

# 자원.
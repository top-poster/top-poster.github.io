---
layout: post
title: "JavaScript Promise: 언제 어떻게 사용해야 하는지 알아보기"
author: "Logger"
thumbnail: "undefined"
tags: 
---


![Image for post](https://miro.medium.com/max/12000/0*4khm6d13VTxslu3c)

자바스크립트를 매일 사용하는 많은 개발자들은 sync/wait 구문을 사용하는 것을 좋아한다. 이것은 배우기 쉽고 사용하기 쉬울 뿐만 아니라 코드를 더 읽기 쉽고 이해하기 쉽게 만들 수 있습니다. 하지만, 여러분은 때때로 `sync/wait` 구문이 아니라 `약속` 구문을 사용해야 한다는 것을 알고 있었나요?

이 글에서 나는 `약속`이 어떻게 작동되는지, 그리고 언제 그것을 사용해야 하는지 설명하겠다.

# 전제 조건

약속의 기본 용도는 이미 알고 있어야 합니다.

# 막후에서 약속이 작동하는 방식

![Workflow of Promise](https://miro.medium.com/max/1602/0*-DwWPe1HNf3A_3iq.png)

여러분 중 많은 분들이 이미 `약속`의 무대가 무엇인지 알고 있을 거라고 생각해요. 일단 여러분이 `약속` 건설업자에게서 무엇을 하든지 끝내면, 그것은 또 다른 `약속`을 돌려주고 여러분이 건설업자에 쓴 것이 끝나기를 기다린다. 이것은 `충족` 또는 `거부`가 될 것이다.

간단한 예를 살펴보겠습니다.

당신은 결과를 추측할 수 있습니까?

처음에는 1이 인쇄될 게 뻔해 보인다. setTimeout은 비동기식 함수이기 때문에 "나중에 실행될 것"이라고 생각한다. 그러다 `약속`을 만나게 된다. 음, 약속도 비동기식이라 setTimeout을 먼저 만났기 때문에 setTimeout 이후에 실행할 것 같아요.

그래서 여러분은 정답이 `1-2-3-4` 혹은 `1-3-2-4`라고 꽤 확신하는데, 이것은 잘못된 것이다.

내가 만난 많은 개발자들은 `약속`이 비동기식으로 여겨진다는 것을 알고 있었지만, 왜 `약속`이 `비동기`로 여겨지는지는 잘 알지 못했다.

몇 가지 진술을 하겠습니다. 다음 중 몇 개가 정확하다고 생각하는지 확인하십시오.

정답은 모두 O입니다. 모두 정확하다. 아시다시피 JavaScript는 한 번에 하나의 태스크만 실행할 수 있는 단일 스레드 프로그래밍 언어입니다. 그러나 여러 태스크를 효율적으로 관리하기 위해 서로 다른 태스크를 처리하는 순서를 결정할 수 있습니다. 그리고 JavaScript에는 몇 개의 태스크 대기열이 있습니다. 자세한 설명을 드리겠습니다.

## 태스크 대기열은 어떻게 생겼습니까?

![Queue workflow](https://miro.medium.com/max/4224/1*oBobM1V9AFpBf-ds3dhxNg.png)

이게 그들의 모습입니다.

JavaScript에는 여러 개의 태스크 대기열(약 3개 이상)이 있으며 코드 행을 한 줄씩 읽을 때 각 관련 태스크가 하나로 들어갑니다. 예를 들어 다음을 읽는 경우:

```undefined
콘솔.log(1);
```

이 작업은 즉시 실행되지 않습니다. 내용이 "콘솔에서 1 인쇄"인 새 태스크가 태스크 대기열(위의 워크플로에서 노란색, 녹색 또는 빨간색 대기열)로 들어갑니다. 이 작업을 실행할 시간이 되면 콘솔에 인쇄된 번호를 볼 수 있습니다. 당신에게는 너무 기본이니까 더 이상 얘기하지 않을게요.

그러나 문제는 "현재 태스크가 어떤 태스크 대기열로 이동하는지 어떻게 알 수 있습니까?"입니다.

## 각 코드가 언제 실행될지 어떻게 압니까?

![Diagram showing when each code is executed](https://miro.medium.com/max/2900/1*Z6CnDJw4o2YP6lLKbnSA6g.png)

이 게시물은 약속에 관한 것이므로 약속으로 설명하도록 하겠습니다.

교통 신호와 좌회전이나 직진하려는 운전자들을 생각해 보자.

빨간 차들은 현재 좌회전 신호등이 켜져 있기 때문에 좌회전하고 있다. 하지만 빨간 차 뒤에 있는 녹색 차들은 어떨까요? 그들은 곧장 가서 교차로를 건너기를 원하지만, 모든 빨간 차들이 떠날 때까지 기다려야 한다.

이 짧은 시연은 `약속` 과제가 작동하는 방식을 닮았다.

JavaScript는 내부적으로 명령을 여러 조각으로 분류합니다. 이 글에서 기억해야 할 한 가지는 약속은 콘솔.log, 새 날짜() 등 비동기식으로 간주되지 않는 다른 작업과 다르게 분류된다는 점이다.

위의 시연에서 약속은 교차로를 건너기 위해 직진할 차례를 기다리는 녹색차다. 다른 동기식 작업들은 빨간 자동차들이 좌회전하는 것입니다. 녹색차가 가고 싶은 차가 모두 떠날 때까지 기다려야 하듯이 약속은 동기식 작업을 위한 대기 행렬이 비어 있을 때까지 기다려야 한다. 이것은 매우 중요하기 때문에, 약속은 모든 동기식 작업이 완료될 때까지 기다려야 한다는 것을 반복할 것이다.

약속의 생성자 내부 영역이 비동기적이지 않기 때문에 먼저 해결이 기록됩니다. 약속에 또 다른 약속을 보낸다.그리고 나서 "the"라는 메시지와 함께 "the". 이 영역은 비동기 영역이기 때문에 다른 동기식 작업이 모두 실행될 때까지 기다려야 합니다. 그리고 저 아래에는 무한의 루프가 있습니다. 그래서 그 프로그램은 영원히 그 안에 갇히게 될 것입니다. 약속의 일지를 볼 기회가 없다.그렇다면

![The relationship between Promise (asynchronous) and synchronous tasks](https://miro.medium.com/max/3776/1*gWgl6XVGV3gDURIO1fCw6g.png)

위의 다이어그램은 약속과 동기식 작업의 관계를 설명합니다.

# 당신은 언제 약속을 사용해야 합니까?

## 원하는 순서대로 태스크를 배치할 때

약속 태스크는 동기식 태스크 대기열이 비어 있어야 실행되므로 약속/대기 대신 약속을 사용하는 것이 매우 유익하다.

`sync/wait` 구문을 사용하여 일부 API를 가져온다고 가정합시다.

login API를 가져온 후에는 changeUIC 구성 요소를 실행하고 updateProfile API를 가져온 후에는 reloadPage를 실행해야 합니다. 이 코드에서 프로그램은 `로그인` 및 `updateProfile`이 각 줄에 대한 결과를 반환할 때까지 기다려야 합니다.

그러나 `약속`을 사용하면 실행 시기를 늦춤으로써 특정 순서로 하고 싶은 작업 중 보다 안전한 순서를 만들 수 있다.

처음 두 줄의 `변화`UIC 구성 요소 및 updateProfile은 동기화된 대기열을 비운 후 "goo"가 실행되면 실행됩니다. updateProfile이 결과를 반환하면 reloadPage가 수행됩니다.

## 성능 향상 시

이 예제를 살펴보도록 하겠습니다.

my-page 페이지에서 사용자는 가져오기 및 로드되는 세 가지 정보(사용자 정보, 청구 기록 및 친구 목록)를 기다립니다.

my-page 페이지에서 가장 중요한 데이터는 나에 대한 정보다. 따라서 사용자가 관련 데이터를 가져올 때까지 기다리도록 하는 것이 더 나은 것 같지만, 다른 데이터는 어떻습니까? 청구 내역 또는 사용자의 친구 수를 미리 가져올 필요가 없습니다. 따라서 이 코드를 약간 리팩터링합니다.

이제 페이지가 처음 렌더링될 때 사용자 정보만 가져옵니다. 그런 다음 청구 내역과 친구 목록을 가져옵니다.

사용자는 처음 렌더링할 때 덜 중요한 데이터를 기다릴 필요가 없습니다.

# 결론

`약속`은 실행되기 전에 항상 동기화된 모든 작업이 완료될 때까지 기다려야 합니다. 실제로 자바스크립트 규격은 동기식 작업이 일반 작업 대기열에서 진행되는 대기열을 호출하고 마이크로 작업 대기열에서 `약속`이 진행되는 대기열을 호출한다.

약속은 적절한 장소에 두고 더 나은 성과를 도출하기 위해 `약속`을 사용할 수 있다는 점도 언급했습니다.
---
layout: post
title: "JavaScript의 어댑터 패턴"
author: "Logger"
thumbnail: "undefined"
tags: 
---


![Striped pattern](https://miro.medium.com/max/4000/0*eeDgyiq0ckk1XJTF)

어떤 기능이 `어댑터`로 접미사가 되어 있는 코드를 접해 본 적이 있는가? 어댑터 패턴을 사용하여 두 인터페이스 간의 동작 호환성을 통합한 코드를 읽고 있었을 가능성이 있습니다. 이 자료에서는 JavaScript의 어댑터 패턴을 살펴보고 패턴이 중요한 이유와 현대 프로그래밍에서 이로운 이유를 설명합니다.

어댑터가 작동하는 방식은 인터페이스의 속성 및 메서드를 새 클래스로 원활하게 조정하는 기능(클래스는 될 수 있지만 클래스로 구현할 필요는 없음)을 생성하는 것입니다. 마치 어댑터를 식별하여 원래 인터페이스와 같이 작동하면서도 새 인터페이스를 사용할 수 있는 것처럼 작동합니다.

JavaScript의 웹 기술이 지속적으로 발전함에 따라 오늘날 오픈 소스 프로젝트(예: axios-mock-adapter)에서 사용되는 이러한 패턴을 쉽게 볼 수 있습니다.

# 어떻게 생겼음

JavaScript에서 어댑터 패턴을 쓰는 올바른 방법이 없습니다. 그러나 이들 모두 동일한 목표를 공유하고 있습니다. 즉, 한 인터페이스에서 다른 인터페이스로 호환성을 제공하는 것입니다.

예를 들어, 개체 목록을 가져와서(다음 예에서는 각각 작업 개체라고 함) 배열의 `액션` 인스턴스로 변환한 다음 모든 실행 방법을 호출하는 다른 함수로 변환하는 기능이 있다면, 구현에 대한 새로운 소개는 이와 유사한 내용을 따라야 합니다.호환성을 유지하려는 경우 에러페이스를 사용합니다.

일반적인 `동작`을 공유하는 작업 개체를 살펴보겠습니다.유형 속성:

이러한 클래스가 주어지면 다음을 정의합니다.

작업 개체의 배열을 가져와서 실행할 수 있도록 준비하는 `액션 체인`이 있다고 가정해 보겠습니다.

각 작업은 모두 호환되는 인터페이스를 공유하기 때문에 앱에서 문제 없이 실행됩니다.

앱에 새로운 작업을 도입하고 싶지만 보다 간결하고 강력한 구문을 사용하고자 하는 경우, 새로운 구현이 실행될 때 현재 프로그램을 중단시킬 경우 이 정보를 기억해야 합니다.

우리가 회사를 위해 프런트 엔드에서 일하고 있고 우리 팀 관리자가 `페이지 점프` 객체(예: `{ action)를 대체/비하하고 싶다고 가정해 보자.유형: "pageJump", 대상: "/contact }`)과 같은 더 짧은 구문인 "{goo: "/contact}"로 이동합니다. 앱에서 이렇게 변경하면 코드가 끊어질 거예요. 이는 우리의 주자인 runActions가 새로운 구문에 존재하지 않는 실행 방법을 실행시키기 때문이다.

우리는 프로그램이 동일한 방식으로 동작할 수 있도록 어댑터로 `이동` 작업을 지원함으로써 이 문제를 해결할 수 있습니다.

먼저 기본 `Action`을 확장하는 클래스를 만들 수 있습니다.

goto는 기본적으로 page jump의 또 다른 버전(종료 목표는 동일)에 불과하기 때문에 두 어댑터 중 하나를 취하여 ActionChain에서 실행할 수 있는 다른 어댑터를 정의할 수 있다.

이렇게 하면 우리의 `페이지 점프` 행동이 그대로 유지될 수 있다. 뿐만 아니라, 우리는 그들에게 goto가 가지고 있는 확장된 방법(예: 이것에 대한 액세스 권한)을 사용하도록 할 수 있다.history 및 새 URL 설정(원하는 경우

이제 기존 코드 중 일부를 마이그레이션할 때 변경 사항이 발생하지 않도록 하면서 앱을 계속 개발할 수 있습니다.

# 기타 예

저는 다른 관점에서 본 더 많은 사례들이 개발자들이 개념을 훨씬 더 잘 이해하는데 도움이 된다고 생각합니다. 그래서 여기 이 패턴을 활용하는 몇 가지 사례들이 더 있습니다.

## 계산기.

다음은 요지에서 인용한 예입니다.

오래된 계산기를 사용하여 계산기 앱을 만든 경우 새 계산기 인터페이스로 작동하는 방법을 제공하려면 새 계산기의 동작과 일치하는 방법이 필요합니다.

아래 예는 문제를 해결하는 어댑터를 사용하여 작성되었습니다.

## Axios 어댑터

기사 앞부분에서, 나는 약속의 사용과 원래의 콜백 접근법을 지원함으로써 호환성을 제공하기 위해 코드에서 어댑터 패턴을 사용하는 axios-mock-adapter에 대해 언급했다.

구문이 눈에 띄게 다르기 때문에 이것이 좋은 예이다. 하지만, 그들 둘 다 결국 목표를 달성합니다. 이거 되게 잘 맞네.

# 결론

이것으로 이 기사를 마치겠습니다! 이게 가치 있는 일이라고 생각하셨기를 바랍니다. 앞으로 더 많은 것을 조심하세요!
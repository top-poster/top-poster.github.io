---
layout: post
title: "반응형 D3 차트 생성"
author: "Logger"
thumbnail: "undefined"
tags: 
---


![Image for post](https://miro.medium.com/max/1248/1*W-UiVhiN8hDGRnP68uOueg.png)

이전 기사 "Easier D3.js - Relder C3 Charts With React Functional Components"에서 우리는 C3가 D3의 모든 복잡성을 알지 않고도 차트를 빠르게 구축할 수 있다는 점에 주목했다. 차트를 만들기 위해 C3을 사용하는 것은 단지 몇 줄의 코드일 뿐이다.

또 다른 기사인 "반응 기능 구성 요소로 D3.js를 렌더링하는 5단계"에서는 D3가 그래픽 표현을 구성할 수 있는 풍부한 기능을 제공한다고 언급했다. 차트를 예로 들어보자. D3는 축, 도형, 도구 설명, 텍스트, 색상 및 애니메이션의 모든 세부 정보를 사용자 정의할 수 있다.

이 기사에서는 D3 라인과 막대 차트를 자세히 살펴보고 D3의 복잡성과 기능을 직접 경험해 보겠습니다.

# C3 차트

이전 예제에서는 C3 선 차트를 구현하는 데 몇 개의 선이 어떻게 필요한지 보여드렸습니다.

Create React App 환경에 다음과 같이 표시됩니다.

![It takes just a few lines to implement a C3 line chart](https://miro.medium.com/max/1248/1*TEHzOi7XyaiV2tF4IgfP4g.png)

막대 차트를 만들려면 13호선 막대형만 바꾸면 된다.

그런 다음 C3 선 차트가 C3 막대 차트로 변경됩니다.

![The C3 line chart changes to a C3 bar chart.](https://miro.medium.com/max/1248/1*qVwHptVTVXnZLhdS2qnzcw.png)

# D3 차트

고급 반응 입력 필드 및 탭을 위한 반응 구성 요소 저장소를 만들었습니다. 이 리포지토리에 D3 차트가 추가됩니다.

```undefined
git clone https://github.com/JenniferFuBook/react-components.git
```

d3 패키지를 기존 `재코일` 패키지와 함께 종속성에 설치합니다.

```undefined
"종속성": {
"@https-dom/https-dom": "^5.11.6",
"@parth-disc/disc": "^11.1.2",
"@skip-skips/user-event": "^12.2.2",
"d3": "^6.3.1",
"^17.0.1",
"dom-dom": "^17.0.1",
"^4.0.1",
"실": "^0.1.2",
"tyled-components": "^5.2.1",
"web-contract": "^0.2"입니다.4"
}
```

src/components에서는 차트 폴더가 생성되어 차트 관련 파일을 저장합니다.

차트에는 세 가지 유형의 설정이 있습니다.

Recil은 SVG 레이아웃 상태 관리에 사용됩니다. 기타 정보는 소품으로 저장되고 하위 구성요소로 전달됩니다.

C3 차트와 유사하게 D3 차트 인터페이스를 정의합니다.

라인 2는 `폭`을 지정합니다.

라인 3은 `높이`를 지정한다.

각 어레이의 첫 번째 항목이 직렬 이름(라인 6 및 라인 7)이라는 점을 제외하고 `data.contract`는 데이터 계열 값입니다.

9행은 차트 유형을 지정합니다.

우리는 라인 6과 라인 7에 정의된 두 개의 데이터 시리즈를 사용하여 차트를 부분적으로 구현하려고 합니다.

```undefined
1. 차트 상태 관리
2. X축
3. Y축
4. 선 차트
5. 전설
6. 막대 차트
7. 애니메이션
8. 일반 차트
9. 이야기책
```

# 차트 상태 관리

리코일은 원자를 사용하여 상태를 유지합니다. SVG 레이아웃에 대한 원자는 `src/component/chart/chartStates.js`에서 생성된다.

선 6-11은 여백 객체를 정의합니다.

16-19행은 폭 아톰을 정의하는데 기본값은 margin.left와 margin.right의 합이다.

24-27행은 높이Atom을 정의하며 기본값은 여백의 합입니다.맨 위`와 `맨 위`입니다.밑바닥의

32-35행은 `marginAtom`을 정의하며, 기본값은 `margin` 객체로 설정됩니다.

이 원자들은 이 차트의 모든 코드에서 사용할 수 있다.

# X축

x축은 좌표계의 주 축 또는 수평 축이다. x축을 따라 있는 점은 다른 모든 좌표에 대해 0의 값을 갖습니다. D3에서 x축은 `스케일 선형`이라는 함수로 쉽게 정의될 수 있다.

scaleLinear는 연속 스케일링을 위한 함수를 구성하며, `domain` default는 `[0, 1]이고, `range` default는 `[0, 1]이다. 도메인과 범위를 지정해야 할 것 같습니다.

scale 선형은 일반적으로 scale의 경계를 설정하는 domain은 척도의 경계를 설정한다. [30, 200, 100, 400, 150, 250]의 데이터 시리즈는 x 값 0에 대해 30, x 값 1에 대해 200이 된다. 따라서 도메인(domain)을 [0, 5]로 설정합니다.

scaleLinear.domain은 일반적으로 scale의 매핑된 경계를 설정하는 range와 연결된다. 예를 들어 SVG 너비는 120px, 좌우 여백은 10px다. 차트의 x 위치는 `[10, 110]` 범위이다.

`x = scaleLinear(.domain(.0, 5]).range([10, 110])를 정의하는 경우 다음 코드 조각은 함수 `x`의 작동 방식을 보여준다.

범위 값은 숫자가 아닐 수 있습니다. 다음은 빨강과 파랑 사이의 색상의 예이다.

도메인과 범위 모두 특정 척도를 정의하기 위해 두 개 이상의 값을 가질 수 있다.

다음은 `src/components/Charts/XAxis`에 정의된 `XAxis` 구성 요소입니다.js:

7호선은 Recoil의 width atom에서 width를 얻는다.

8호선은 리칠의 높이 아톰에서 높이를 얻는다.

9호선은 리칠의 마진 아톰에서 왼쪽 오른쪽 아래를 얻는다.

라인 10은 라인 22에서 제어되지 않는 구성 요소를 참조하는 `ref`를 생성한다.

12-20라인은 dom을 변이시키는 d3 코드를 호출하기 위해 layout effect를 사용한다.

선 13-15는 x축에 대한 선형 척도를 만듭니다.

16라인은 하단 수평축을 만드는 `축 하단`을 사용한다. 여러 개의 하단 수평 축을 만들 수 있으며, `축 상단`을 사용하여 이 축들이 맨 위에 있을 수도 있습니다.

라인 17은 ticks 번호를 데이터 시리즈 수와 tickSize로 설정합니다.바깥쪽은 0이다. 실제로 눈금 표시 위치, 눈금 레이블 형식 및 축의 끝 위치에 대해 많은 사용자 정의를 수행할 수 있습니다.

라인 19는 제어되지 않는 구성 요소에 x축을 인스턴스화합니다.

라인 22는 x축에 대한 SVG 그룹을 정의합니다. 여백 하단을 제외한 x축을 SVG 하단에 배치합니다.

`XAxis.js`에는 다음과 같은 x축이 표시됩니다.

![X-axis displayed by XAxis.js.](https://miro.medium.com/max/1248/1*WfTyeEQAzrGz_VgzXsauVA.png)

# Y축

Y축은 좌표계의 2차 또는 수직 축이다. 이 값을 따라 있는 점은 다른 모든 좌표에 대해 0의 값을 갖습니다.

다음은 `src/components/Charts/에 정의된 `YAxis` 구성 요소입니다.YAxis.js`:

위의 코드는 `src/components/Charts/XAxis.js`와 매우 유사합니다. 두 가지 차이점은 다음과 같습니다.

x축과 y축이 모두 생성되면 다음 좌표를 볼 수 있습니다.

![Graph after creating the x-axis and y-axis.](https://miro.medium.com/max/1248/1*hJutGBW338Z56XEg3HYHfw.png)

# 선 차트

선 차트는 y 번호가 x 수에 따라 어떻게 변하는지 표시합니다. 시간에 따른 추세와 발전뿐만 아니라 변화하는 시계열도 보여주는 데 이상적입니다.

우리는 `스케일 리니어`를 사용하여 x축과 y축의 직선을 그렸습니다. 선 시리즈는 각 점을 연결하는 경로입니다. 이러한 점을 연결하는 데 `라인` 함수가 사용됩니다. 선은 일반적으로 척도 선형 함수에 의해 생성된 x 및 y 함수와 결합된다.

```undefined
constrainFn = 선➡
.x(,i) => x(i)
.y((d) => y(d);
```

각 데이터 시리즈 `i`에 대해 SVG 그룹에 경로가 추가됩니다. 경로는 영상 시리즈 이름을 제외한 `data.columns[i] 값을 사용합니다. 특정 스트로크 설정으로 채워지지 않은 경로를 구성한 다음 `라인Fn` 함수를 호출하여 점을 연결합니다.

```undefined
선택(컨테이너 참조 전류)
.the path')
.vht(값)
.notfill', 'none')
.사격', () => '파란색')
.sk-width', 1.5)
.스트라이크 라인 결합', '둥근')
.영국 스트로크 라인 캡', '둥근')
.attr('d', 라인Fn);
```

위의 코드에서 파란색은 라인 색상으로 사용됩니다. 하지만 둘 이상의 경로를 사용할 경우 경로를 구별하기 위해 서로 다른 색상을 사용해야 합니다. 스케일 Ordinal은 색상을 설정하는 데 사용할 수 있습니다. scale Ordinal은 단순히 값을 명명하는 것을 넘어 특정 순서로 값을 배열하는 순서척도의 함수를 구성한다.

schemSet1은 RGB 16진수 문자열로 표현되는 9개의 범주형 색상으로 구성된 배열이다. color = scaleOrdinal(.range(.schemSet1)을 정의할 경우 다음 코드 조각은 `color` 함수의 작동 방식을 보여준다.

2-10행은 9개의 범주형 색상을 출력합니다.

이후, 9가지 색상은 재사용됩니다. color(0)는 color(9)의 color(1)와 color(10)의 color(1)의 color(0)는 color(10)의 color(color)와 같다.

위의 스케일 Ordinal은 레인지와 직접 연결된다. 색 이름의 배열인 `도메인`입니다. 가운데에 사슬로 묶일 수도 있습니다. 다음 예에서는 처음 두 개의 색 이름을 data1과 data2로 정의합니다.

2-10행은 9개의 범주형 색상을 출력합니다.

이후 동일한 색상이 다시 재사용됩니다. color ➡data1)는 color(7) ➡color ➡data2)와 color(8) ➡color ➡color ➡color ➡color ➡color ➡color(8) 등과 같다.

우리는 `color`를 `src/components/Charts/constant.js`에서 공통 함수로 정의한다.

3번 라인에서는 `SchemeSet1`에서 처음 두 색상을 제거합니다. 그래서 저희 차트에는 총 7개의 범주형 색상이 있습니다. 이는 단순히 두 데이터 시리즈에 대해 세 번째와 네 번째 색상을 선호하기 때문입니다.

다음은 `src/components/Chart/LineChart.js`에 정의된 `LineChart` 구성 요소입니다.

8호선은 리칠의 폭 아톰에서 폭을 얻는다.

9호선은 리칠의 높이 아톰에서 높이를 얻는다.

10호선은 리칠의 마진 아톰에서 좌, 우, 상, 하로 연결된다.

라인 11은 라인 40에서 제어되지 않는 구성 요소를 참조하는 `ref`를 생성한다.

13-38번 노선은 dom을 변형시키는 d3 코드를 호출하기 위해 layout effect를 사용한다.

라인 14는 라인 29가 추가했을 수 있는 이전 경로를 제거합니다.

선 16-18은 x 방향에 대한 선형 척도를 만듭니다.

선 19-21은 해당 방향에 대한 선형 척도를 만듭니다.

선 23-25는 각 데이터 열에 대한 점을 연결하는 선 함수를 만듭니다.

선 27-37은 각 데이터 열을 사용자 정의하고 그립니다.

`라인 차트` 구성 요소는 다음 이미지를 렌더링합니다.

![Image rendered by the LineChart component.](https://miro.medium.com/max/1248/1*e-VW08nfwwU20hzeu9T6IA.png)

# 레전드

우리는 꺽은선형 차트를 그렸습니다. 그러나 범례가 없으면 어떤 선이 어떤 데이터 시리즈와 정렬되었는지 알 수 없습니다.

C3 범례는 색상이 지정된 정사각형 및 데이터 열 이름을 표시합니다. 컬러 데이터 시리즈 이름을 표시하도록 단순화합니다. 데이터 시리즈의 수에 따라 스케일 리니어(scale Linear)를 사용하여 영상 시리즈의 이름을 배치하고 텍스트 태그로 표시합니다.

다음은 `src/components/Charts/Legend.js`에 정의된 `Legend` 구성 요소입니다.

8호선은 리칠의 폭 아톰에서 폭을 얻는다.

9호선은 리칠의 높이 아톰에서 높이를 얻는다.

10호선은 리칠의 마진 아톰에서 좌, 우로 연결된다.

라인 11은 라인 27에서 제어되지 않는 구성 요소를 참조하는 `ref`를 생성한다.

13-25행은 dom을 변형시키는 d3 코드를 호출하기 위해 layout effect를 사용한다.

선 14-16은 x 방향에 대한 선형 척도를 만듭니다.

18-24행은 D3 코드이다. keys는 일련의 시리즈 이름이다. 코드는 텍스트 요소를 만들어 x 위치(22행), 색상(23행) 및 텍스트(24행)에 맞게 사용자 지정합니다.

라인 27은 범례 그룹을 정의하며, 이 범례 그룹은 x축 아래에 `20px`로 배치된다.

다음은 범례가 있는 선 차트입니다.

![A line chart with a legend](https://miro.medium.com/max/1248/1*VUxc74UpM4RKudc2VDFj8g.png)

# 막대 차트

막대형 차트는 값에 비례하는 높이 또는 길이를 가진 직사각형 막대를 사용하여 범주형 데이터를 비교하는 데 사용됩니다.

막대형 차트는 y 값을 계산하기 위해 scaleLinear를 사용하는 반면 x 값은 순서형 또는 범주형 차원에 대한 함수를 구성하는 scaleBand에 의해 계산되며, scaleBand는 일반적으로 []로 기본 설정되며, scaleBand는 [0, 1]로 기본 설정되며, scaleBand는 일반적으로 [domain]과 "range"로 연결된다.

스케일 밴드는 연속 스케일을 생성하지 않습니다. 대신, 그것의 규모는 별개이다. 또한 밴드 너비를 생성하는 기능도 있다.

`x = scaleBand(.domain(.[0, 5]).range([10, 110])를 정의하는 경우 다음 코드 조각은 함수 `x`의 작동 방식을 보여준다.

위 코드에서는 도메인 배열 `[0, 5]`의 값만 값(라인 2 및 라인 7)을 반환합니다. 도메인 배열에 두 개의 값이 있으므로 [10, 110] 범위는 두 개의 밴드로 분할됩니다. 각 밴드의 폭은 50(라인 9)이다. 시작 범위가 10인 것을 감안하면 첫 번째 값은 10(2행)이 되고, 두 번째 값은 60(7행)이 된다.

range (stop)는 0에서 `stop — 1`까지의 숫자 시퀀스를 생성하는 함수입니다.

range(6)를 사용하여 [0, 1, 2, 3, 4, 5] 범위의 값을 생성합니다. 범위 함수의 반환 값으로 `도메인`을 생성함으로써, 우리는 `도메인`의 각 항목에 대한 x 값을 얻는다.

다음은 `src/components/Chart/BarChart.js`에 정의된 `BarChart` 구성 요소입니다.

위의 코드는 다음과 같은 차이를 제외하고 `src/components/Chart/LineChart.js`와 매우 유사합니다.

다음은 범례가 있는 막대 차트입니다.

![A bar chart with a legend](https://miro.medium.com/max/1248/1*OG2itn03x0Ffs8e71ExXCA.png)

# 애니메이션

우리는 선 차트와 막대 차트를 만들기 위해 꽤 많은 코드를 작성했습니다. C3 차트에 비해 D3 축과 범례는 원시적이며, 데이터 열 그림은 도구 팁, 선택, 응답성 등을 놓치게 됩니다.

D3 차트를 작성하는 것이 노력할 만한 가치가 있습니까?

네, 그래요. D3는 그래픽 표현을 구성하기 위한 풍부한 기능을 제공한다. 그것은 많은 고급 기능들을 위한 문을 연다. 위의 기초 작업으로 애니메이션은 몇 줄의 코드로 추가될 수 있다.

전환(transition)은 DOM의 변경 사항을 애니메이션하기 위한 선택형 인터페이스입니다. 즉시 변경 사항을 적용하는 대신 `전환`은 DOM의 변경 사항을 해당 기간 동안 현재 상태에서 원하는 대상 상태로 보간한다.

다음 코드는 배경색을 `빨간색`으로 변환한다.

```undefined
선택(선택)
.전환기
.스타일의 배경색 '빨간색')
```

전환은 일반적으로 `➡`과 `➡`로 연결되며, 그 다음에 `➡`로 연결된다. `ㄹ`은 지정된 값으로 전환 기간을 밀리초 단위로 설정합니다. ease는 easeLinear와 같은 전이 완화 기능을 명시한다.

```undefined
선택(선택)
.전환기
.201(1000)
.ease(쉬운 선형)
.스타일의 배경색', '빨간색'
```

또한 전환은 밀리초 단위로 지연될 수 있습니다.

```undefined
선택(선택)
.전환기
.201(1000)
.ease(쉬운 선형)
.202(2000)
.스타일의 배경색', '빨간색'
```

`attrTween`은 선택한 각 요소에 대해 평가되는 함수의 속성을 할당합니다. 스트로크-대시 배열 속성은 경로의 스트로크 모양을 형성하는 데 사용되는 대시 및 간격의 패턴을 제어합니다. 스트로크-대시 배열 속성을 보간하면 길이 0부터 전체 길이까지 스트로크를 애니메이션화할 수 있다.

```undefined
구성 요소 = (경로) =>
오솔길
.전환기
.vd(vd)
.ease(쉬운 선형)
.attrTween('stro-dasharray'), 함수() {
상수 길이 = this.getTotalLength(;
intervalate('0, ${length})를 반환합니다. ('${length}, ${length};
});
```

다음은 애니메이션 코드를 가진 `src/components/Chart/LineChart.js`입니다.

위의 코드에서 두 가지 변경 사항이 적용됩니다.

이 비디오 클립은 선차트가 애니메이션화되는 방식을 보여 줍니다.

우리는 막대 차트 애니메이션을 조금 다르게 디자인합니다. 모든 막대는 0의 높이에서 시작하여 최대 높이까지 성장합니다.

다음은 애니메이션 코드를 가진 `src/components/Chart/BarChart.js`입니다.

위의 코드에서 두 가지 변경 사항이 적용됩니다.

이 비디오 클립은 막대 차트가 애니메이션화되는 방식을 보여 줍니다.

# 일반 차트

이제 라인차트와 바차트 구성 요소를 갖추었으니 이를 담을 일반적인 차트 구성 요소를 만들어야 한다. 폭 높이 여백 데이터 등을 소품으로 삼는다. 차트 유형을 기준으로 적절한 x축, y축 및 범례와 함께 선 차트 또는 막대 차트를 표시합니다.

다음은 `src/components/Chart/Chart.js`에 정의된 `Chart` 구성 요소입니다.

3-8호선은 관련된 모든 코드를 가져옵니다.

라인 15-21은 반동 상태에서 SVG 레이아웃을 설정합니다. 폭과 높이가 필요하며, 폭은 선택 사항입니다.

가장 긴 데이터 열인 가장 긴 열(25라인)을 계산해 데이터 시리즈 이름(26라인)에 맞는 키를 쌓고 가장 큰 y 값(27라인)을 절약한다. 최소값이 `0`이라고 가정했습니다.

막대 차트의 눈금 카운트는 `가장 긴 열 - 1`이고, 선 차트의 눈금 카운트는 `가장 긴 열 - 2`(줄 30–33)입니다.

34호선은 x도메인을, 35호선은 y도메인을 구성한다.

선 38-48은 전체 차트를 SVG 요소로 조립합니다. viewBox는 SVG의 치수를 정의하는 속성이다. 차트 치수를 고정하기 위해 폭과 높이에는 별도의 속성이 있습니다. 제거된 차트는 자동으로 확대축소됩니다.

# 스토리북

우리는 스토리북을 사용하여 선 차트와 막대 차트를 보여줍니다. 두 가지 이야기는 `src/구성 요소/차트/차트.스토리`로 쓰여 있다.js:

6-9호선은 차트 스토리를 설정해 리코일루트 안에 넣었다.

13-17행은 선차트 스토리를 구성합니다.

29-42행은 막대 차트 스토리를 구성합니다.

차트는 인덱스 파일에서 4행에서 가져옵니다. 이 파일은 `src/components/Charts/index.js`이며 외부용으로 생성됩니다.

Storybook의 라인 차트는 다음과 같습니다.

![The line chart on Storybook.](https://miro.medium.com/max/1710/1*-ptT5JwYM3k_Xfjatf2t9w.png)

Storybook의 막대 차트는 다음과 같습니다.

![The bar chart on Storybook.](https://miro.medium.com/max/1710/1*Q5Yfoq2v906erNEvwKsKXA.png)

# 결론

D3는 데이터 기반 문서를 나타냅니다. 전체 구성 요소 대신 이러한 구성 요소를 생성하는 데 사용할 수 있는 데이터 기반 도우미 기능을 제공합니다. 반응 차트와 같은 D3 라이브러리를 구축하는 데 시간이 더 오래 걸릴 수 있습니다. 그러나 데이터가 구축되는 즉시 데이터 시각화를 위한 많은 가능성을 열어줍니다.

차트의 경우 C3 또는 D3 중에서 선택할 수 있습니다.

읽어주셔서 감사합니다. 이게 도움이 됐으면 좋겠어요. 여기 제 다른 매체 출판물을 보실 수 있습니다.
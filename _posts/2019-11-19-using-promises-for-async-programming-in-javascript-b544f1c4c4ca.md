---
layout: post
title: "JavaScript에서 비동기 프로그래밍에 대한 약속 사용"
author: "Logger"
thumbnail: "undefined"
tags: 
---


![Image for post](https://miro.medium.com/max/8064/1*cI8R6E-Z8lr7g4XpoHFuzw.jpeg)

JavaScript는 단일 스레드 언어이기 때문에 동기 코드는 한 번에 한 줄만 실행할 수 있습니다. 즉, 동기 코드가 순간보다 오래 실행될 경우 실행 중인 코드가 완료될 때까지 나머지 코드의 실행이 중지됩니다. 일정 시간 동안 실행되는 코드가 다른 코드가 실행되지 않도록 하려면 비동기 코드가 있어야 합니다.

# 약속들

자바스크립트에서 이것을 하기 위해서, 우리는 우리의 코드에서 약속을 사용할 수 있습니다. 약속은 일정하지 않은 시간 동안 실행되며 성공 또는 실패를 초래할 수 있는 프로세스를 나타내는 개체입니다. JavaScript에서 약속을 만들기 위해 약속 생성자인 `약속` 개체를 사용합니다. 약속 생성자는 해결 매개 변수와 거부 매개 변수가 있는 실행자 함수라는 함수를 사용합니다. 두 가지 매개 변수 모두 약속을 이행하기 위해(어떤 값으로 성공적으로 종료함을 의미) 또는 약속을 거부하기 위해(일부 오류 값을 반환하고 약속을 실패한 것으로 표시) 호출하는 함수입니다. 함수의 반환 값은 무시됩니다. 그러므로, 약속은 약속 이외의 어떤 것도 반환할 수 없습니다.

예를 들어, 다음 코드와 같이 JavaScript에서 약속을 정의할 수 있습니다.

```undefined
약속 = 새 약속((해결, 거부) = {
setTimeout((() => resolve ➡'), 1000);
});
```

위의 코드는 1초 후 abc 값으로 약속을 이행하는 약속을 만든다. 실행자 함수 내에서 setTimeout을 실행하여 1초 안에 abc 값을 가진 약속을 해결하기 때문에 비동기 코드입니다. setTimeout의 콜백 함수 내에서 abc 값을 반환할 수 없으므로 resolve(`abc`)를 호출해야 해결된 값을 반환합니다. 우리는 `그때` 기능을 사용하여 이행된 약속의 해결된 가치에 접근할 수 있다. `then` 함수는 이행된 약속의 확인된 값을 매개 변수로 사용하는 콜백 함수를 사용합니다. 당신은 그 가치를 얻을 수 있고 그것으로 당신이 원하는 것을 할 수 있습니다. 예를 들어 다음과 같은 작업을 수행할 수 있습니다.

```undefined
약속 = 새 약속((해결, 거부) = {
setTimeout((() => resolve ➡'), 1000);
});
약속.그러면 (발) => {
console.log(val);
})
```

위의 코드를 실행하면 abc가 기록됩니다. 우리가 볼 수 있듯이, 약속은 `해결` 기능에 대한 호출을 통해 약속이 이행될 때 가치를 제공할 것입니다.

약속에는 세 개의 주가 있다. 보류 중일 수 있으며, 이는 약속이 이행되었거나 거부되었음을 의미합니다. 이를 이행할 수 있으며, 이는 작업이 성공적으로 완료되었음을 의미합니다. 또는 약속 작업이 실패했음을 의미하는 거절될 수 있습니다.

보류 중인 약속은 값으로 이행되거나 일부 오류와 함께 거부될 수 있습니다. 약속이 이행되면 해당 확인 값이 `그때` 함수에 의해 선택되고 `그때` 함수에 전달된 콜백 함수가 호출된다. 약속이 거부되면 선택적으로 `catch` 기능으로 오류를 잡을 수 있으며, 이 함수는 오류와 함께 콜백 함수를 사용할 수도 있습니다. 당시 기능과 캐치 기능이 모두 약속을 반납하기 때문에 함께 묶일 수 있다.

예를 들어 다음과 같은 내용을 쓸 수 있습니다.

```undefined
약속 = (숫자) => {
새 약속((해결, 거부) => {
setTimeout((() => {
if (num === 1) {
을 해결하다)
다른 {}개
거절하다)
}
}, 1000);
});
}
약속(1)
.then((발) => {
console.log(val);
})
.disc((오류) => {
console.log(오류);
})
약속 (2)
.then((발) => {
console.log(val);
})
.disc((오류) => {
console.log(오류);
})
```

위의 코드에는 num이 1일 때 resolved로 약속을 이행하는 자바스크립트 약속을 반환하고, 그렇지 않으면 오류 reject로 약속을 거부하는 `약속` 기능이 있다. 그래서 우리는 실행:

```undefined
약속(1)
.then((발) => {
console.log(val);
})
.disc((오류) => {
console.log(오류);
})
```

그러면 `그때` 함수가 실행되며, 약속(1) 함수 호출에서 반환되는 약속은 `num`이 1이므로 충족되며, 해결된 값은 `val`로 설정된다. 그래서 우리가 `console.log(val)`를 실행하면 `resolved. 아래 코드를 실행할 때:

```undefined
약속 (2)
.then((발) => {
console.log(val);
})
.disc((오류) => {
console.log(오류);
})
```

그러면 약속(2) 함수 호출에 의해 반환된 약속이 거부되고 거부된 오류 값이 오류로 설정되므로 "catch" 함수가 실행됩니다. 따라서 `console.log(error)`를 실행하면 `거부`가 기록됩니다.

JavaScript 약속 개체에는 `길이` 및 `프로토타입`의 속성이 있습니다. 길이가 항상 1인 생성자 인수의 수에 대해 `길이`의 값은 항상 1로 설정됩니다. 프로토타입 속성은 약속 객체의 프로토타입을 나타냅니다.

약속은 또한 약속의 이행 여부에 관계없이 실행되는 코드를 실행할 수 있는 `최종` 방법을 가지고 있다. `마침내` 방법은 약속 결과에 관계없이 실행할 코드가 모두 실행되는 콜백 함수를 인수로 사용합니다. 예를 들어 다음을 실행합니다.

```undefined
약속해.reject error')
.then((값) => {
console.log(값);
})
.disc((오류) => {
console.log(오류);
})
.vht((() => {
console.log가 실행됩니다';
})
```

그러면 오류라는 이유로 원래 약속이 거부되었기 때문에 오류와 최종 실행이라는 로그가 기록됩니다. 그러면 finally(마지막) 메서드에 대한 콜백에서 어떤 코드가 실행되든 실행된다.

비동기 코드 작성에 약속을 사용할 때의 주요 이점은 약속을 사용하여 비동기 코드를 순차적으로 실행할 수 있다는 것이다. 그러기 위해 우리는 그때의 기능과 약속을 연결시킬 수 있다. 그러면 `then` 함수는 약속이 이행될 때 실행되는 콜백 함수를 사용합니다. 또한 약속이 거절될 때 두 번째 주장을 해야 한다. 약속의 사슬을 끊기 위해, 우리는 `그때` 함수의 첫 번째 콜백 함수의 반환값으로서 또 다른 약속을 반환해야 한다. 만약 우리가 기존의 약속에 또 다른 약속을 묶고 싶지 않다면, 그것은 아무것도 아닌 것처럼 다른 가치들을 되돌려 줄 수 있다. 값을 반환할 수 있으며, 이 값은 해결되어 다음 `then` 함수에서 검색할 수 있습니다. 또한 오류를 발생시킬 수도 있습니다. 그러면 그때가 돌려준 약속은 던져진 오류를 값으로 하여 거절된다. 또한 이미 이행되거나 거부된 약속을 반환할 수 있으며, 이 약속은 `그때` 함수가 그 뒤에 사슬에 묶여 있을 때 충족된 값을 얻거나 `catch` 함수에 대한 콜백에서 오류 이유를 얻는다.

예를 들어 다음을 작성할 수 있습니다.

```undefined
약속.해결(1)
.그렇다면 (val => {
console.log(val);
반환 약속.해결 (2)
})
.그렇다면 (val => {
console.log(val);
})
약속.해결(1)
.그렇다면 (val => {
console.log(val);
약속에 답하다.reject error')
})
.그렇다면 (val => {
console.log(val);
})
.disc(오류 => 콘솔.log(오류);
약속.해결(1)
.그렇다면 (val => {
console.log(val);
새 오류('error')를 던집니다;
})
.그렇다면 (val => {
console.log(val);
})
.control(오류 => console.log(오류)
```

첫 번째 예에서, 우리는 약속을 묶었고 그들은 모두 가치로 해결했다. 모든 약속은 이미 가치로 해결되었다. 두 번째와 마지막 예에서는 두 번째 약속을 거부하거나 오류를 범합니다. 둘 다 같은 일을 해요. 두 번째 약속은 거부되고 오류 이유는 `catch` 함수에 대한 콜백에 기록됩니다. 다음 코드와 같이 보류 중인 약속도 연결할 수 있습니다.

```undefined
constance1 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(1), 1000);
});
constance 2 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(2), 1000);
});
약속1
.그렇다면 (val => {
console.log(val);
약속 반환2;
})
.그렇다면 (val => {
console.log(val);
})
.control(오류 => console.log(오류)
```

당시 첫 번째 함수에 대한 콜백은 약속2를 반환했는데 이는 미결된 약속이다.

# 방법들

JavaScript 약속에는 다음과 같은 방법이 있습니다.

## 약속해. 모두(불가결)

약속해."all"은 일부 컴퓨터에서는 여러 약속을 병렬로 실행할 수 있는 반복할 수 있는 객체를 채택하고 있다. 이것은 서로의 가치관에 의존하지 않는 여러 약속을 실행할 때 유용합니다. 그것은 보통 배열인 약속의 목록과 함께 불가사의한 것을 받아들인 다음, 불가사의한 약속이 해결되었을 때 해결된 하나의 `약속`을 반환한다.

예를 들어, 다음과 같은 코드를 작성하여 `약속`으로 여러 약속을 실행할 수 있다.모두:

```undefined
constance1 = Promise.resolve(1);
제약 조건 2 = 2;
constance3 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(3), 1000);
});
약속.모두([약속1,약속2,약속3])
.then((값) => {
console.log(값);
});
```

위의 코드를 실행하면 "console.log"가 "[1,2,3]"로 기록됩니다. 우리가 볼 수 있듯이, 그것은 모든 약속이 이행된 후에야 해결된 가치를 돌려준다. 만약 그들 중 일부가 거절된다면, 우리는 어떤 결정 가치도 얻을 수 없을 것입니다. 대신, 우리는 거부된 약속에 의해 반환되는 오류 값을 얻게 될 것입니다. 첫 번째 거부된 약속에서 중지되고 해당 값을 "catch" 함수에 대한 콜백으로 보냅니다. 예를 들어 다음과 같은 경우가 있습니다.

```undefined
constance1 = Promise.resolve(1);
약속 2 = 약속.불합격 (2);
constance3 = 새로운 약속((해결, 거부) = {
setTimeout((() => reject(3), 1000);
});
약속.모두([약속1,약속2,약속3])
.then((값) => {
console.log(값);
})
.disc(오류 => {
console.log(오류);
});
```

그러면 "catch" 함수에 대한 콜백에 있는 "console.log"에서 2가 기록됩니다.

## 약속해.전원결제

약속해.All Settled는 주어진 약속이 모두 해결되거나 거부된 후에 해결되는 약속을 반환한다. 그것은 예를 들어, 일련의 약속과 같은 약속들의 집합과 함께 반복할 수 있는 목적을 가진다. 반환된 약속의 해결된 값은 각 약속의 최종 상태에 대한 배열입니다. 예를 들어 다음과 같은 경우를 가정해 보겠습니다.

```undefined
constance1 = Promise.resolve(1);
약속 2 = 약속.불합격 (2);
constance3 = 새로운 약속((해결, 거부) = {
setTimeout((() => reject(3), 1000);
});
약속해.모두 결제됨([약속 1, 약속 2, 약속 3])
.then((값) => {
console.log(값);
})
```

위의 코드를 실행하면 세 개의 항목이 있는 배열을 얻게 되는데, 각 항목은 이행된 약속에 대한 `상태`와 `가치` 속성을 갖는 객체와 거부된 약속에 대한 `상태`와 `이성` 속성을 갖는 객체가 된다. 예를 들어 위의 코드는 `{status: "fulfuled", 값:1}, `{status: "distance", 이유: 2}, "{status: "dief", 이유: 3} 이행된 상태는 성공적인 약속에 대해 기록되고 거부된 약속에 대해서는 거부된 상태로 기록된다.

## '약속.경주

`Promise.race` 방법은 먼저 이행한 약속의 해결된 가치로 해결되는 약속을 반환합니다. 그것은 예를 들어, 일련의 약속과 같은 약속들의 집합과 함께 반복할 수 있는 목적을 가진다. 만약 통과된 가설이 비어있다면, 반환된 약속은 영원히 보류될 것이다. 해당 객체에 하나 이상의 약속되지 않은 값이나 이미 정해진 약속이 포함되어 있다면 Promise.race는 이 항목 중 첫 번째 항목으로 되돌아간다. 예를 들어 다음과 같은 경우가 있습니다.

```undefined
constance1 = Promise.resolve(1);
constance 2 = Promise.resolve (2);
constance3 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(3), 1000);
});
약속.레이스([약속1, 약속2, 약속3])
.then((값) => {
console.log(값);
})
```

그러면 `1`이 기록됩니다. 다음 회선을 실행하기 전에 즉시 해결되기 때문에 `약속1`이 가장 먼저 해결되기 때문이다. 마찬가지로, 다음 코드와 같이 인수로 전달하는 어레이에 약속되지 않은 값이 있는 경우:

```undefined
제약 조건 1 = 1;
constance 2 = Promise.resolve (2);
constance3 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(3), 1000);
});
약속.레이스([약속1, 약속2, 약속3])
.then((값) => {
console.log(값);
})
```

그러면 우리가 `Promise.race` 방식으로 전달하는 것은 어레이에서 약속되지 않은 값이기 때문에 동일한 내용이 기록됩니다. 동기 코드는 항상 비동기 코드보다 먼저 실행되므로 동기 코드가 어디에 있든 상관 없습니다. 다음과 같은 경우:

```undefined
constance1 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(1), 2000);
});
constance 2 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(2), 1000);
});
제약 조건 3 = 3;
약속.레이스([약속1, 약속2, 약속3])
.then((값) => {
console.log(값);
})
```

그러면 "setTimeout"이 콜백 기능을 나중에 실행할 대기열에 넣기 때문에 "3"이 기록되므로 동기 코드보다 늦게 실행될 것입니다.

마지막으로 다음과 같은 경우:

```undefined
constance1 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(1), 2000);
});
constance 2 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(2), 1000);
});
약속.레이스([약속1, 약속2])
.then((값) => {
console.log(값);
})
```

그러면 1초 안에 해결된 약속은 2초 안에 해결된 약속보다 빨리 해결되기 때문에 콘솔 로그에 `2`가 표시됩니다.

## 약속해.배척하다

약속해.거절하는 것은 거절된 약속을 이유와 함께 반환합니다. `오류`의 예인 개체와의 약속을 거부하는 것이 유용합니다. 예를 들어 다음과 같은 코드가 있는 경우:

```undefined
약속해.reject(새 오류('rejected')')
.then((값) => {
console.log(값);
})
.disc((오류) => {
console.log(오류);
})
```

그러면 `거부`가 기록됩니다.

## '약속.해결'

"Promise.resolve"는 해결된 약속을 "resolve" 함수의 논쟁에 전달된 값으로 반환합니다. 우리는 또한 `그때` 속성이 있는 객체를 전달할 수 있는데, 여기서 객체의 가치는 약속의 콜백 함수이다. 값에 `그때` 방법이 있으면 `그때` 함수에 의해 충족된 값으로 약속이 이행된다. 즉, `then` 함수의 값에 대한 함수의 첫 번째 매개변수는 `resolve`와 같고, 두 번째 매개변수는 `reject`와 같다.예를 들어, 다음을 작성할 수 있습니다.

```undefined
약속.해결(1)
.then((값) => {
console.log(값);
})
```

그러면 1이 해결 함수에 전달된 값이기 때문에 1이 기록되어 해결 값 1을 반환하게 됩니다.

다음 코드와 같이 내부에 `then` 메서드가 있는 개체를 전달하면 다음과 같습니다.

```undefined
Promise.resolve({})
그런 다음(거부, 거부) {}
해결(1);
}
})
.then((값) => {
console.log(값);
})
```

그러면 값 `1`이 기록됩니다. 왜냐하면 Promise.resolve 함수는 then 함수를 실행하고, resolve 매개 변수는 then 속성으로 설정된 함수의 resolve 매개 변수는 약속에서 resolve 함수와 같은 함수로 가정하기 때문이다. 대신 전달된 객체의 `그때` 함수 내부의 `거부` 함수를 호출하면 다음과 같은 코드에서처럼 거부된 약속을 받게 된다.

```undefined
Promise.resolve({})
그런 다음(거부, 거부) {}
reject error';
}
})
.then((값) => {
console.log(값);
})
.disc((오류) => {
console.log(오류);
})
```

위의 코드에는 약속이 거부되어 `오류`가 기록됩니다.

# 비동기 및 대기

sync와 wait로 약속 코드를 단축할 수 있다. `sync`와 `기다리기` 전에는 `그때` 기능을 사용해야 했고 `그때` 기능을 모두 주장으로 콜백 기능을 넣어야 했다. 이것은 우리가 약속이 많은 한 코드를 길게 만든다. 대신 sync와 wait 구문을 사용하여 then 기능과 관련 콜백을 대체할 수 있다. 예를 들어 다음 코드를 줄일 수 있습니다.

```undefined
constance1 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(1), 2000);
});
constance 2 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(2), 1000);
});
약속1
.then((val1) => {
console.log(val1);
약속 반환2;
})
.then((val2) => {
console.log(val2);
})
```

다음을 위해:

```undefined
constance1 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(1), 2000);
});
constance 2 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(2), 1000);
});
(httpsc () =>
constance1 = 약속 대기1;
console.log(val1)
constance2 = wait promise2;
console.log(val2)
})()
```

우리는 그때와 콜백을 기다림으로 대체했다. 그러면 각 약속의 해결된 값을 변수로 지정할 수 있습니다. 약속 코드에 wait를 사용할 경우 위의 예에서처럼 함수 서명에 sync를 넣어야 합니다. 마지막에 `catch` 기능을 체인화하는 대신 오류를 잡기 위해 `catch` 조항을 사용한다. 또 약속이 끝났을 때 코드를 실행시키기 위해 하단의 finally 함수를 체인하는 대신 catch 조항 뒤에 finally 절을 사용한다.

예를 들어 다음과 같이 쓸 수 있습니다.

```undefined
constance1 = 새로운 약속((해결, 거부) = {
setTimeout((() => resolve(1), 2000);
});
constance 2 = 새로운 약속((해결, 거부) = {
setTimeout((() => reject error'), 1000);
});
(httpsc () =>
{}을(를) 시도하다
constance1 = 약속 대기1;
console.log(val1)
constance2 = wait promise2;
console.log(val2)
} 캐치(오류) {
console.log(오류)
} 마침내 {}
console.log가 실행됩니다';
}
})()
```

위의 코드에서 우리는 위의 `const response = wait promise1` 행처럼 `then` 함수의 콜백에서 값을 얻는 대신 변수에 할당된 약속의 확인된 값을 얻었다. 그리고 `try... catch...`도 사용했는데마지막으로 약속에 무슨 일이 있어도 코드가 실행될 수 있도록 콜백(callback)이 전달된 `반대` 함수 대신 `반대` 조항의 오류를 잡기 위해 차단한다.

약속을 사용하는 다른 기능과 마찬가지로 `아닌c` 기능은 항상 약속을 반환하고 다른 것은 반환할 수 없다. 위의 예에서, 우리는 콜백이 인수로 전달된 `그때` 기능보다 훨씬 더 짧은 방법으로 약속을 체인화할 수 있다는 것을 보여주었다.

# 씌우다

약속만 있으면 우리는 비동기식 코드를 쉽게 쓸 수 있다. 약속은 일정하지 않은 시간 동안 실행되며 성공 또는 실패를 초래할 수 있는 프로세스를 나타내는 개체입니다. JavaScript에서 약속을 만들기 위해 약속 생성자인 `약속` 개체를 사용합니다.

약속 생성자는 해결 매개 변수와 거부 매개 변수가 있는 실행자 함수라는 함수를 사용합니다. 두 가지 매개 변수 모두 약속을 이행하기 위해(어떤 값으로 성공적으로 종료함을 의미) 또는 약속을 거부하기 위해(일부 오류 값을 반환하고 약속을 실패한 것으로 표시) 호출하는 함수입니다. 함수의 반환 값은 무시됩니다. 그러므로, 약속은 약속 이외의 어떤 것도 반환할 수 없습니다.

약속은 약속에 보답하기 때문에 사슬에 묶일 수 있다. 약속의 `그때` 기능은 오류를 던지거나, 해결된 가치를 반환하거나, 보류 중이거나, 이행 중이거나, 거부된 다른 약속을 반환할 수 있다.
---
layout: post
title: "오픈 소스 리액션 프로젝트에서 코드 10K 라인을 리팩터링했습니다."
author: "Logger"
thumbnail: "undefined"
tags: 
---


![Diagram of the article’s main point: Restructured code led to better code reuse and fewer lines.](https://miro.medium.com/max/3208/1*YbmzuKOJoq-to747SMRzxA@2x.png)

어떤 프로젝트를 할 때, 특히 MVP 단계에서, 우리는 개발자로서 코드를 작성할 때 다른 무엇보다도 한 가지를 우선시한다: 그것이 제대로 작동하는지 확인하는 것이다. 안타깝게도 이는 MVP의 요구사항에 과도하게 초점을 맞춘 코드를 작성하는 것을 의미할 수 있기 때문에, 우리는 결국 유지하기 어렵거나 확장하기가 번거로운 코드를 갖게 된다. 물론, 우리가 이상적인 세계에 살고 있지 않기 때문에 쉽게 피할 수 있는 문제는 아닙니다. 시간의 힘은 항상 우리에게 불리하다. 때때로 우리는 단지 무언가를 밀어낼 필요가 있다.

저는 Firetable을 구축하는 소프트웨어 엔지니어입니다. 이 앱은 스프레드시트 UI와 Firestore 및 Firebase의 모든 기능을 결합한 오픈 소스 Retact 앱입니다. 우리는 간단한 `짧은 텍스트`에서 복잡한 `커넥트 테이블` 필드에 이르기까지 모든 다양한 필드 유형의 코드인 몇 가지 기본 코드로 이 문제에 부딪혔다.

리팩토링 후, 이제 더 많은 기능을 구축할 수 있는 보다 탄탄한 기반을 갖추게 되었고, 찾기 어려운 버그를 몇 개 제거했으며, 이제 기여자들이 새로운 필드 유형을 어떻게 작성할 수 있는지에 대한 가이드까지 얻게 되었습니다.

# 코드에서 냄새가 나고 기술 부채가 큰 문제가 되었을 때

처음 Firetable을 구축하기 시작했을 때, 아이디어는 스프레드시트 인터페이스를 구축하는 것이었습니다. 당연히, 결과물은 그것과 아주 잘 맞았습니다. 오래된 스크린샷을 보면 Excel 및 Google Sheets와 같은 스프레드시트 프로그램과 얼마나 닮았는지 놀라울 따름입니다.

![An old screenshot of Firetable with a UI very similar to that of a spreadsheet program](https://miro.medium.com/max/4320/1*AErT3puN8KMYoq2STuA6YA@2x.jpeg)

이를 구현하기 위해 반응 데이터 그리드를 사용했습니다. 사용자가 셀을 두 번 클릭할 때 셀 렌더링에 사용되는 "포맷터" 구성요소 및 셀 편집에 사용되는 "편집자" 구성요소를 수신한다. 포맷터(formaters)와 에디터(editor)가 테이블(Table) 코드와 함께 폴더가 되는 등 이를 중심으로 코드를 구성했다.

몇 달 후, 우리는 메인 테이블 위로 미끄러지는 형태의 UI인 사이드 드로어를 추가했다. 한 번에 단일 행의 모든 필드를 쉽게 편집할 수 있도록 설계되었으며, 이를 통해 사용자는 일상적인 작업흐름을 확인할 수 있습니다. 당시 이 새로운 코드를 구성하는 가장 논리적인 방법은 테이블을 구성하는 것과 비슷해 보여서 사이드 드로어 폴더에 필드 폴더를 만들었다.

![Screen recording of a user selecting a cell and opening the side drawer](https://miro.medium.com/max/2560/1*1h6w52_v9rflIGJ9WlDPGw.gif)

하지만 우리가 이 코드를 유지하자 균열이 보이기 시작했습니다.

우리의 독특한 필드 유형 중 하나는 `Action`으로, 사용자가 Firebase Cloud Functions를 사용하여 행의 데이터에 기반하여 코드를 실행하고 결과를 동일한 셀에 표시할 수 있도록 하는 버튼을 테이블에 표시합니다. Firebase Auth 사용자 지정 역할을 사용하여 Firetable 내에서 데이터베이스의 액세스 제어를 설정하는 것과 같은 새로운 애플리케이션에 사용했습니다.

Action 셀에 의해 호출될 때 Cloud Function이 올바른 파라미터를 수신하지 못하는 버그가 발생했습니다. 그러나 코드를 업데이트하려면 테이블 포맷터와 사이드 드로어 필드 등 두 곳에서 코드를 업데이트해야 했다. 뿐만 아니라, 시간 제약 때문에 클라우드 기능이라는 코드를 복제한 것으로 밝혀졌습니다. 공유 코드를 위한 명확한 위치가 없었고 버그는 너무 우선순위가 높아서 그 질문에 정확하게 대답할 시간이 없었습니다.

마지막으로 우리가 칼럼 잠금 기능을 일관성 없이 구현했다는 것을 알게 되었을 때였다. 사이드 드로어에서는 편집이 가능했지만 테이블에서는 편집이 되지 않거나 또는 그 반대로 실행하지 않은 필드도 있습니다. 이는 각 필드 유형에 대한 최소 요구 사항을 구현한 후 이 기능을 추가한 결과이므로 각 테이블 포맷터와 사이드 드로어 필드를 모두 거쳐야 했습니다. 이는 필드 유형의 두 배입니다. 이 지루한 수작업은 분명히 오류가 나기 쉬웠다.

이 시점에서, 우리는 리팩터링할 때가 왔다는 것을 알았다.

# 성공을 위한 리팩터링

주요 문제는 다음과 같습니다. 필드 유형별로 코드를 저장할 수 있는 공간이 한 군데도 없었습니다. 코드 베이스에는 테이블 포맷터 및 에디터, 사이드 드로어 필드, 컬럼 설정 등이 흩어져 있었다. 이 산란은 필드 유형에 새로운 기능을 추가하고 버그를 걸러내는 비용을 급격히 증가시켰다.

우리가 한 첫 번째 일은 코드 구조에 대한 우리의 접근 방식을 완전히 뒤집는 것이었습니다. 필드 유형을 사용할 각 피쳐별로 코드를 그룹화하는 대신 필드 유형별로 코드를 그룹화했습니다.

![Diagram visualising the new code structure](https://miro.medium.com/max/2944/1*WWYzKwqxCegAGdUCGrK9ig@2x.png)

새 접근 방식은 각 필드 유형의 하위 폴더로 구성된 `필드`라는 새로운 최상위 구성요소 폴더로 변환됩니다. 각 파일에는 TableCell.tsx와 SideDrawerField.tsx와 같은 파일이 있습니다. 그런 다음 구성 개체로 이러한 기능을 내보낼 수 있으므로 이 코드를 모두 소비자가 한 번만 가져오면 됩니다. 이것은 리액트 훅스에 의해 해결된 문제와 유사하다: 관련 코드를 그룹화하고 라이프사이클 방법을 생각할 필요가 없다.

이 접근 방식은 또한 코드베이스 전체에서 필드 코드를 가져오는 방법을 단순화한다. 이전에 테이블과 사이드드로어에서는 올바른 구성 요소를 가져와 각 필드를 하나씩 가져올 수 있을 때까지 각 필드 유형을 순환하는 스위치 문장에 의존했다. 따라서 새로운 필드 유형을 추가할 때마다 이러한 `스위치` 블록에도 새로운 항목을 추가해야 하며, 이는 다시 개발 비용을 크게 증가시킨다. 대신 모든 필드 구성으로 단일 어레이를 생성한 후 코드베이스에서 공유할 수 있습니다. 따라서 새로운 필드 유형을 한 번만 정의하면 됩니다.

또한 구성 개체를 사용하면 새로운 기능을 신속하게 구현할 수 있으며 모든 필드가 올바르게 구현되는지 확인할 수 있습니다. 이제 필드 구성에 속성이 있는지 간단하게 확인할 수 있습니다. 또한 TypeScript를 사용하므로 각 구성 개체는 특정 유형의 특정 기능(인터페이스 속성)을 적용할 수 있는 인터페이스를 구현해야 합니다(예: Retact 구성 요소에서 특정 소품을 허용하는 등). 이 새로운 기능을 통해 우리는 칼럼 잠금 장치 구현을 수정할 수 있었고 새로운 기능인 칼럼의 기본값을 개발하기가 훨씬 쉬웠다. 인터페이스에 새 속성을 추가하기만 하면 되었습니다.

![Example of the significant amount of code we were able to reduce with the new code structure](https://miro.medium.com/max/3352/1*hZOSFJh_EeAxy-NyVpXjXw@2x.png)

이를 염두에 두고 리팩터는 코드를 유지 보수하고 버그를 수정하기 쉽게 만들었을 뿐만 아니라, 필드를 위한 고급 기능을 구축하고 추가 개발 비용을 제거할 수 있는 훨씬 더 확실한 기반을 제공했습니다.

# 미래를 위한 교훈

물론, 우리가 처음에 이 방법을 사용했더라면 이 모든 고통과 추가 작업을 피할 수 있었을 것이다. 하지만 우리는 이상적인 세계에 살고 있지 않습니다. 앞에서 말씀드린 모든 비이상적인 솔루션은 특히 일상 업무에 직접적인 영향을 미치는 다른 프로젝트를 동시에 수행할 때 발생하는 시간 제약의 결과였습니다.

우리들 중 많은 사람들은 코드 품질이 우수하지 않은 사업을 주된 목표로 삼고 있습니다. 저는 글로벌 초창기 벤처 캐피털 회사인 앤틀러에서 일하는데, 만약 이것이 우리에게 맞는다면 저는 매우 충격을 받을 것입니다. 개발자로서 당사는 비즈니스 요구사항을 충족하는 기술 솔루션을 구축하기 위해 고용되며, "방법"은 추상화됩니다. 그러나 이 경우, 구조화되지 않은 코드와 발생한 기술 부채의 양이 작업 능력에 직접적인 영향을 미치고 있었습니다.

그리고 이 기사를 쓰다가 우연히 리팩토링을 보게 되었습니다.구루, 리팩터링에 대한 훌륭한 가이드입니다. 우리는 리팩터링 시기에 대한 그들의 첫 번째 권고에 분명히 만족했다: "세 번째 무언가를 할 때는 리팩터링을 시작하라."

이 경험은 우리에게 코드 구조와 리팩터가 필요할 때 많은 귀중한 교훈을 주었다. 우리의 여정을 읽고 통찰력이 생겼기를 바랍니다.
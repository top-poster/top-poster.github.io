---
layout: post
title: "단일요소 집합체의 각도에 미치는 영향"
author: "Logger"
thumbnail: "undefined"
tags: 
---


![Miniature action figure](https://miro.medium.com/max/7744/0*ZFt5dTYEx_IzMUAX)

저는 오늘 Angular 앱에서 단일 요소 컬렉션을 사용하는 힘에 대한 생각을 나누고자 합니다. 일상 업무에서 이런 활용 사례를 자주 발견하기 때문에, 여러분도 유용하게 활용할 수 있을 것입니다.

먼저 일반적인 것으로 시작하겠습니다.

```undefined
<워크 아이템 카드>
*ngFor="선택한 작업 항목의 let 항목"
[항목]="항목"
>
```

우리는 그러한 코드를 여러 번 보았고 그것은 우리에게 매우 자연스러워 보인다. 선택한 Work Items 어레이에 새 요소를 추가할 때마다 Angular는 구성 요소의 새 인스턴스를 초기화하고 뷰 내에서 렌더링합니다. 영업은 평상시와 같음.

다음 사항을 고려하십시오. 선택한 작업 항목 컬렉션은 0 또는 1 요소를 가질 수 있습니다.

이러한 시나리오에서 `*ngFor`를 위한 자리가 남아 있는가, 아니면 구성 요소의 `선택한 작업 항목` 단일 필드로 전환해야 하는가?

# *ngFor를 사용하여 단일 요소만 렌더링할 수 있음

구성 요소 템플릿에서 다음 구조를 생각해 보겠습니다.

구성 요소:

```undefined
선택된항목: WorkItem = null;
항목 선택(항목: WorkItem) {이것.선택된품목 = 품목 };
```

역시, 평범해 보인다. 컬렉션(`작업 항목`)이 있으며 사용자가 클릭해서 하나의 요소를 선택할 수 있습니다. 일단 선정되면 *ngIf를 통해 워크 아이템 카드 구성 요소를 공개합니다.

기존 방식이지만 잘못 사용하면 의도한 대로 작동하지 않을 수 있습니다.

# *ngIf 조건이 참인 한 동일한 구성 요소 인스턴스 유지

사용자가 항목을 클릭하고 선택한 항목을 변경하면 어떻게 되는지 생각해 보십시오.

이 상태는 `선택됨`과 같이 진실로 유지됩니다.Item 필드는 절대 null이 아니므로 *ngIf는 작업 항목 카드 구성요소를 계속 표시합니다. 입력 `[항목]`만 값을 변경합니다.

작업 항목 카드 구성 요소 설정 논리는 다시 실행되지 않습니다. 시공자 및 ngOnInit는 신규 입력값에 대해 실행되지 않는다. 첫 번째 클릭 후에 초기화됩니다. 그게 전부입니다. 아시다시피, 이 논리는 종종 구성요소의 주요 입력에 따라 크게 좌우됩니다. 다시 실행하지 않음으로써 구성 요소의 부적절한 동작을 위험에 처하게 됩니다.

물론 `워크 아이템 카드` 구성 요소를 리팩터링할 수도 있다. 세터를 추가하고, 코드의 복잡성을 가중시킨 다음, 이와 같은 문제를 해결합니다. 그러나 입력에 대한 여러 세터가 있는 구성 요소는 세터 간에 내부 논리가 분산되어 있어 유지 보수 및 확장이 항상 어렵습니다. 그래서 저는 업무용 아이템 카드를 만지는 것은 분명히 잘못된 방법입니다.

지금 당장 원하는 것은 다른 항목을 선택할 때마다 작업 항목 카드 구성 요소의 새 인스턴스를 생성하는 것뿐입니다.

# 단일 항목 모음을 사용하여 항목 선택 메커니즘을 구현할 수 있습니다.

처음에 언급했듯이, "*ngFor"는 당신이 새로운 레코드를 컬렉션에 넣을 때마다 당신에게 새로운 구성 요소의 인스턴스를 제공한다. 그럼 왜 지금 사용하지 않는 거죠?

다음 방법으로 코드를 다시 작성할 수 있습니다.

구성 요소:

```undefined
선택된항목: WorkItem[] = [];
항목 선택(항목: WorkItem) {이것.선택된항목 = [항목] };
```

모든 것이 예전처럼 작동하지만 더 좋다. 새 항목을 선택할 때마다 `작업 항목 카드` 구성 요소의 새 인스턴스가 표시됩니다!

*ngIf를 *ngFor로 대체하셨고 지금은 모든 것이 더 간단합니다. 작업 항목 카드 구성 요소 구현은 건드리지 않아도 됩니다. 작업 항목을 선택하고 해당 구성 요소를 가져옵니다. 그만큼 간단합니다. 우리가 원하던 대로, 매번 새로운 예시로군.

# 결론.

선택한 항목을 단일 필드 대신 배열에 보관하면 세터의 복잡한 메이즈가 생성되지 않고 하위 구성 요소의 init 로직은 `ngOnInit` 방식으로만 유지할 수 있습니다.

사실, 대부분의 시나리오에서는 아무것도 잃지 않으며 전반적인 성능에 미치는 영향은 미미합니다.

해피 코딩!
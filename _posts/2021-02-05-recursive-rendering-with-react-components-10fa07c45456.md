---
layout: post
title: "반응 구성 요소를 사용한 재귀 렌더링"
author: "Logger"
thumbnail: "undefined"
tags: 
---


![Folder structure](https://miro.medium.com/max/2278/1*l9EHVlnVNXAwa1ppDGnV1g.png)

Wikipedia는 다음과 같은 재귀에 대해 설명합니다.

프로그래밍 용어에서, 그것은 스스로 호출하는 함수이다. 이 개념을 설명할 수 있는 최소한의 예는 다음과 같습니다.

위의 단편들을 보면, 여러분은 몇 가지를 깨닫게 될 것입니다. 우선, 여러분은 이것이 가능하다는 사실을 몰랐을지도 모릅니다. 비록 당신이 그것을 할 수 있다는 것은 다소 직관에 어긋나지만 말이다. 우리는 함수의 본체를 구성하는 동안 함수를 호출합니다. 그건 정말 좀 이상하네요.

이렇게 말하면, 여러분은 아마도 이 특정 조각에 대해 뭔가 구체적인 것을 발견했을 것입니다. 그것은 결코 멈추지 않을 것이다. 무한 루프입니다!
그리고 당신이 옳을 것이다. 저희 브라우저는 이를 좋아하지 않으며 수천 번 반복한 후 이를 보류합니다.

![Error message](https://miro.medium.com/max/768/1*Vn3jZMfyOQmR4Wm31OpYbw.png)

왜냐하면 우리의 작은 설명적 기능에는 이런 일이 일어나는 것을 막을 수 있는 어떤 논리도 포함되어 있지 않기 때문입니다. 단말 조건이 없습니다. 하지만 곧 보게 될 것처럼 추가하기도 쉽습니다.

![Example of recursive rendering](https://miro.medium.com/max/1410/1*6IeCtpSx57lMSsFU_2b5yA.png)

참고: 아래 모든 코드는 GitLab의 내 리포지토리에서 찾을 수 있습니다.

# 반응 재귀

우리는 단지 함수가 자신을 호출할 수 있다고 설명했습니다. React 구성 요소도 기능이기 때문에 다음과 같이 렌더링할 수 있습니다.

다시, 위의 내용을 렌더링하면 루프가 종료되는 조건이 없기 때문에 무한 루프가 발생합니다. 그러나 루프가 5회만 반복되도록 하는 간단한 논리(그리고 간단한 인라인 스타일링)를 추가할 경우:

결과는 다음과 같습니다.

![Recursive rendering of a React component](https://miro.medium.com/max/1400/1*l3eOuOsXW_wcoAU_Hy4h9g.png)

보시는 바와 같이 마이 컴포넌트는 마이 컴포넌트 안에 렌더링되며, 이 과정은 다섯 번 반복되었습니다. 신기하죠, 그렇죠?

이를 실제 사례에서 활용할 수 있는 방법에 대해 간략히 살펴보겠습니다. 많은 사용 사례가 있지만, 전통적인 사용 사례는 중첩된 데이터를 렌더링하는 것입니다. 중첩된 데이터의 예로는 파일 시스템의 디렉토리 구조가 있습니다. 디렉토리에는 디렉토리 등을 포함할 수 있는 디렉토리도 포함될 수 있습니다.

대신 더미 데이터를 사용하겠지만 효과는 같습니다. 앞에서 살펴본 바와 같이, 다음과 같은 작업을 수행할 예정입니다.

![Example of recursive rendering](https://miro.medium.com/max/1410/1*6IeCtpSx57lMSsFU_2b5yA.png)

# 데이터 원본

먼저 트리의 모든 항목(행)을 나타내는 몇 가지 데이터로 시작합니다. 파일이 `nested`입니다.TreeData.json`은 다음과 같습니다.

![The first seven records in our JSON file](https://miro.medium.com/max/900/1*LBZENObIvF_juEl7uULQzg.png)

NAT은 플랫 데이터 구조를 가지고 있습니다. 모든 레코드가 동일한 레벨에 존재합니다. 기록에는 기록이 없고, 제 생각으로는 기록되어서는 안 됩니다. 그것은 여러분의 삶을 훨씬 더 쉽게 만들 것입니다. 저는 이 개념에 대해 전문 기사를 썼고, 나중에 꼭 읽어보길 권합니다.

레코드에 `parentId`라는 속성이 어떻게 포함되어 있는지 확인하십시오. 같은 목록에 있는 다른 레코드에 대한 포인터입니다. 그들은 어떤 기록이 그들의 조상인지 정의한다. 처음 세 개의 레코드는 parentId가 없습니다(영(0과 같음). 그것들은 최고 수준의 기록이다. 최고 기록인 과일에는 씨트러스, 돌과일, 베리: 세 명의 후손(자녀)이 있다.`

![Top-level record and its descendants](https://miro.medium.com/max/298/1*l1j59fGhiQGnE8xKmTKGpw.png)

# 데이터 준비

JSON 파일을 읽고 데이터를 준비하는 유틸리티 기능을 만듭니다. 반환하기 전에 수행하는 유일한 작업은 각 레코드(`has Children`)에 새 부울 속성을 추가하는 것입니다. 이 속성을 가리키는 레코드가 있는지 여부를 나타냅니다.

우리는 부모에게 아동 기록을 추가하지 않습니다. 우리는 우리의 데이터 구조를 평평하게 유지하기를 원하며, 우리는 이것이 우리에게 어떻게 도움이 되는지 곧 알게 될 것이다.

위의 함수에 의해 반환된 데이터는 트리 데이터라는 이름으로 우리의 트리 구성 요소(다음 섹션 참조)에 전달됩니다.

# 트리 구성 요소

트리 구성 요소는 재귀 마법이 발생하는 곳입니다. 우리는 나무 안에 나무를 심을 것이다. 이때 뜨거운 음료를 한 모금 마시고 따라가야 한다.

구성요소 정의부터 시작합니다.

treeData 매개변수가 무엇인지 알고 있습니다. 두 번째 "parentId"는 이 값이 "parentId"로 설정된 레코드인 우리가 렌더링할 레코드를 나타냅니다. 구성 요소의 본문을 살펴보기 전에, 우리 페이지의 "트리"를 어떻게 렌더링하는지 빠르게 살펴보겠습니다.

```undefined
= 트리 트리 데이터 = {treeData} / >
```

보시다시피 데이터만 전달합니다. 즉, 트리 구성 요소를 렌더링하는 첫 번째 반복에서는 매개 변수 parentId와 수준(둘 다 0)에 기본값을 사용합니다. 명심하세요.

구성 요소의 본체로 돌아갑니다. 먼저 렌더링할 레코드를 선택합니다.

우리는 또한 할 수 있기 때문에 알파벳순으로 정렬합니다 (4행).

다음 행은 흥미롭고 매우 중요한 행입니다.

만약 우리가 주어진 `부모 ID`에 대한 기록을 찾지 못했다면, 우리는 `null`을 돌려주는 것으로 멈춘다. 지금은 이것에 대해 더 이상 언급하지 않겠지만, 나중에 언급하겠지만, 명심하세요. (스포일러 경고: 무한 루프를 방지함)

그리고 마지막으로, 우리는 우리의 요소들을 돌려줍니다. 발견된 항목에 대해 반복합니다.

8-11행에서 필터링한 각 항목에 대해 행 요소를 렌더링합니다. 각 행 요소에는 하나의 자식, 즉 다른 나무 요소가 있습니다! 최고의 재귀.

이 시점에서 질문이 남아 있을 수 있습니다. 무슨 일이 일어나고 있는지 좀 더 깊이 생각해 봅시다.

# 추가 설명

Tree 구성 요소를 렌더링할 때 데이터 이외의 매개 변수를 전달하지 않았습니다.

```undefined
= 트리 트리 데이터 = {treeData} / >
```

즉, "parentId" 매개 변수와 "level" 값이 "0"인 구성 요소를 렌더링합니다. 그래서 트리 구성품 본체의 맨 위에 있는 데이터를 필터링할 때, 우리는 세 개의 최고 수준의 기록을 남길 것이다.

즉, 라인 2-4의 논리는 다음과 같습니다.

다음 레코드를 선택합니다.

![Three records](https://miro.medium.com/max/1132/1*TWdrcgUGOipFEZSBl0OxMA.png)

그런 다음 이 세 가지 레코드에 대해 각각 `행` 요소를 만듭니다.

이 문서(리포에서 전체 파일을 찾을 수 있음)에 `행` 구성 요소는 표시하지 않겠지만 기본적으로 다음과 같이 렌더링하기만 하면 됩니다.

![One row](https://miro.medium.com/max/194/1*U5sQZACMltCRq4kasYXVPQ.png)

한 행을 렌더링합니다. 하나의 레코드. div 요소로. 화려한 아이콘과 행의 확장 또는 축소 여부를 추적하는 약간의 상태. 이 div 아래에서 한 가지 작업을 더 수행합니다. 그것은 지나간 아이들을 낳는다.

우리는 한 아이를 또 다른 `나무` 요소로 물려주었다! 그리고 우리가 렌더링하던 원래의 `트리` 요소 안에서 모든 과정이 다시 시작됩니다.

재귀 호출입니다.

다른 점은 이번에 다른 속성 값을 사용했다는 것입니다. 트리 데이터는 그대로지만 부모 ID는 현재 렌더링 중인 레코드(예: 과일)의 ID가 된다.

## 무한 루프 방지

우리 `나무`의 몸체 안에 있는 이 선을 기억하십니까?

```undefined
(!contract.length)가 null을 반환하는 경우;
```

이렇게 하면 잠재적인 무한 루프가 중지됩니다. 언제? 트리 구성 요소를 렌더링하기 시작했지만 지정된 부모 ID에 대한 항목(기록)을 찾을 수 없는 상황에 직면했을 때.

# 파이널 워드

재귀는 때때로 여러분의 머리를 감싸기 어려운 주제가 될 수 있습니다. 나는 이 기사가 간단한 예를 통해 당신을 안내함으로써 안개로부터 벗어나기를 바랍니다. 이것은 제가 미디엄 기사에서 자주 사용하는 형식입니다.

제가 마무리하기 전에, "재귀"라는 단어를 구글에 써보셨나요?

결과를 보여주면 Google은 다음과 같이 현명하게 답변합니다.

![Search results](https://miro.medium.com/max/650/1*ZMSbHv6SHRC1Jh-PBMNi6g.png)

시간 내주셔서 감사합니다!
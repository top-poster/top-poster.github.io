---
layout: post
title: "Regular expression. Let's start like this!"
author: "Logger"
thumbnail: "https://heropy.blog/css/images/vendor_icons/javascript.png"
tags: 
---


![image](https://heropy.blog/css/images/vendor_icons/javascript.png)

There will be no one who has never used a regular expression while using JavaScript.
However, many people seem to think that regular expressions should be searched and used.
Of course, regular expressions are not often used in development, and they cannot be considered good readability, so I think many people have delayed studying because it is difficult to use without memorizing patterns.
I summarized it in this document to think about ways to learn more easily than `I have to learn it unconditionally.
I hope it will be helpful for those who start the regular expression for the first time.

# Regular Expression with JavaScript

A regular expression is a type of formal language (pattern) that can be used to search for and replace a string.
You can quickly perform complex character matching functions such as simple text search, email, password checking, and so on with regular expression patterns.
However, it is often difficult for beginners because the regular expression pattern does not match well with the performance.
But you can get used to it quickly if you get the initial concept right.

Regular expressions play a major role:

- Search for characters
- Replace character(replace)
- Character extraction (extract)

JavaScript is one of the languages that supports direct-built regular expressions.
In this post, we will look at the content based on the regular expression (regular expression) used by JavaScript.

> There is a pattern that only works in a particular language or environment.
I couldn't handle all regular expressions, so I organized the documents based on JavaScript.

## Regular Expression Test Site

It is recommended to understand the content and apply it in practice.
Let`s test the regular expression using the sites below.

However, the set environment of each site is different, so it may not work in some ways, or it may work differently from the regular expression covered by JavaScript.
Don`t be blind to the results of the regular expression tested on the site, but make sure to test if it fits your environment.
(Therefore, whether a particular regular expression works or not does not refer to the superiority of the site.)

https://regex101.com/
https://regexr.com/
https://regexper.com/

## Create JavaScript Regular Expression

### Constructor Functional

Available by calling the `RegExp` constructor function.

```js
const regexp1 = new RegExp("^abc");
// new RegExg (expression expression)

const regexp2 = new RegExp("^abc", "gi");
// new RegExg (expression, flag)

```

### Literal method

The regular expression uses a pattern wrapped in `/` as a literal.

```js
const regexp1 = /^abc/;
// Expression/

const regexp2 = /^abc/gi;
// /Expression/Flag

```

In the normal case, the literal method is much more convenient.
However, some situations require the use of the `RegExg` constructor function.

### Re-compile

You can reassign a regular expression in use.
You must declare it as a variable, not a constant.

```js
let regexp1 = /ipsum/g;
regexp1 = /lorem/i;

console.log(regexp1);
// /lorem/i

const regexp2 = /ipsum/g;
regexp2 = /lorem/i; // TypeError

```

## JavaScript Properties

JavaScript has a variety of properties provided by regular expressions.

<table><thead><tr><th>property</th><th>description</th></tr></thead><tbody><tr><td><code>`flags`</
 code></td><td>Return Flag (String), <code>`/^abc/gi.flags`</code></td></tr><tr><td><code>`source
 `</code></td><td>Return expression (String), <code>`/^abc/gi.source`</code></td></tr><tr><td><code
>
`global`</code></td><td>Flag <code>`g`</code> Returns whether (Boolean), <code>`/^abc/gi.global`</code></td></tr><tr><td><code>`ignoreCase`</code></td><td> return flag <code>`i`</code> Boolean</td><
 /tr><tr><td><code>`multiline`</code></td><td> flag <code>`m`</code> return Boolean</td></tr>
 <tr><td><code>`sticky`</code></td><td> flag <code>`y`</code> return Boolean</td></tr><tr>
 <td><code>`unicode`</code></td><td>Flag <code>`u`</code> Returns whether (Boolean)</td></tr></tbody></table>


 

The `flags` property can be useful if only flags are extracted from the regular expression.
Values are returned alphabetically.

```js
new RegExp("^abc", "gi").flags;
// "gi"

/^abc/igy.flags;
// "giy"

```

When extracting expressions, use the `source` attribute.

```js
new RegExp("^abc", "gi").source;
// "^abc"

/^abc/igy.source;
// "^abc"

```

You can also check if the flag is included.

```js
/^abc/igy.global;
// true

/^abc/igy.ignoreCase;
// true

/^abc/igy.unicode;
// false

```

## JavaScript Method

Let`s take a look at the different methods of dealing with regular expressions.

<table><thead><tr><th>method</th><th>grammar</th><th>description</th></tr></thead><tbody><tr><td> <code>`exec`</code></td><td><code>`regular expression.exec(string)`</code></td><td>Return one matching information (Array)</td></tr><tr><td><code>`test`</code></td><td><code>`regular expression.test(string)`</code></td><td>
Return match (Boolean)</td></tr><tr><td><code>`match`</code></td><td><code>`string.match(regular expression)`</code></td><td>Return an Array of matching strings</td></tr><tr><td><code>`search`</code></td><td> <code>`string.search(regular expression)`</code></td><td>Return the index (Number) of the matching string</td></tr><tr><td><code>`replace `</code></td><td><code>`string.replace(regular expression,replacement character)`</code></td><td>Replaces the matching string and returns the replaced string </td></tr><tr><td><code>`split`</code></td><td><code>`string.split(regular expression)`</code></td> <td>Split matching strings and return as array</td></tr><tr><td><code>`toString`</code></td><td><code>` Constructor_regular expression.toString()`</code></td><td>Returns regular expression of constructor function as literal string</td></tr></tbody></table>


 

First, prepare the following sentences for the test.

```js
const str = `Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and smaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.`;

```

For example, ".exec()` can be used as follows:
Returns `null` if no matching results are found.

```js
Regular expression.exec (string);

/ipsum/.exec(str);
// null

/ipsum/i.exec(str);
// ["Ipsum", index: 6, input: "Lorem Ipsum is simply dummy text of the printing aâ€¦ldus PageMaker including versions of Lorem Ipsum.", groups: undefined]

```

The method `.match()`, which is created by reordering regular expressions and strings, can be used as follows:
Returns `null` if there is no matching result as well.

```js
'// String.match (regular expression);

str.match(/ipsum/);
// null

str.match(/ipsum/i);
// ["Ipsum", index: 6, input: "Lorem Ipsum is simply dummy text of the printing aâ€¦ldus PageMaker including versions of Lorem Ipsum.", groups: undefined]

```

If you look closely at the results above, the return results are completely different, but only the insertion of `i` in the flag position is different.
If you don`t know what flag `i` means, you can`t infer the result at all, so I think it`s difficult to express the regular expression.
(Actually, it`s more of a problem with the esoteric special symbols in the expression pattern than the flags.))
For your information, the flag `i` was used to mean `I will not distinguish case in English`.

## Flag

As you can see above, flags can produce completely different results.
The flag is an option for an expression, and you can add additional options to the character pattern that you want to search for as an expression to return the desired character search results.

<table><thead><tr><th>flags</th><th>description</th></tr></thead><tbody><tr><td><code>`g`</
 code></td><td>Match any character and multiple lines (global)</td></tr><tr><td><code>`i`</code></td><td>English
 Match case insensitive (insensitive, ignore case)</td></tr><tr><td><code>`m`</code></td><td>multi line
 </td></tr><tr><td><code>`u`</code></td><td>Unicode</td></tr><tr><td>
 <code>`y`</code></td><td><code>`lastIndex`</code> matches only once at the index specified by the attribute (sticky)</td></tr></tbody>
 </table>


 

### g(global)

The flag used relatively often is `g`.
Let`s take a look at the following example:

```js
str.match(/ipsum/i);
// ["Ipsum", index: 6, input: "Lorem Ipsum is simply dummy text of the printing aâ€¦ldus PageMaker including versions of Lorem Ipsum.", groups: undefined]

str.match(/ipsum/ig);
// (4) ["Ipsum", "Ipsum", "Ipsum", "Ipsum"]

```

One added only `i` as a flag and the other added `ig` to search for the character `ipsum` from the constant `str`.
The flag `g` was used to mean `I will search all characters`.
Therefore, expressions without `g` returned only one (first) search result and expressions with `g` returned all search results as an array.

### m(multi line)

Sets whether to search in multi-line (with line breaks) mode.
To test the flag `m`, insert a line change wherever the period (`.`) is located in the sentence within the `str` variable set above.

> Press Enter on each line.

```js
const strMultyLine = `Lorem Ipsum is simply dummy text of the printing and typesetting industry.
Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.
It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged.
It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.`;

```

We haven`t started the pattern yet, so don`t focus on the expression and just look at the flag.
The following expression means to search `end of line` in the sentence above.
The end of the entire sentence is retrieved and returns one `empty string`, `"".

```js
strMultyLine.match(/$/g);
// [""]

```

If you add the flag `m` here, it can be used to mean that you will search for the end of the line.
Therefore, it searches for `end of line` in all broken lines.
We return a total of four results, including the very end of the entire sentence, along with a total of three line changes we inserted.

```js
strMultyLine.match(/$/gm);
// ["", "", "", ""]

```

### u(unicode)

It is necessary to process Unicode characters.

```js
/ðŸ˜{2,}/.test("ðŸ˜ðŸ˜ðŸ˜ðŸ˜");
// false

/ðŸ˜{2,}/u.test("ðŸ˜ðŸ˜ðŸ˜ðŸ˜");
// true

```

You can also specify a range (interval) of Unicode characters using the pattern `[]` to be viewed below.

```js
/[0-9]/.test("5");
// true

/[ðŸ˜€-ðŸ˜‡]/u.test("ðŸ˜‚");
// true

```

### y(sticky)

The property `lastIndex` is available on the generated regular expression instance.
If you specify a number in this `lastIndex` property and search with the flag `y`, you will only search for characters in the `index` that match that number.

```js
const str = "Have a nice day!";
// index => 0123456789012345

// General Regular Expression
const regexp = /nice/;

// Sticky Regular Expression
const stickyRegexp = /nice/y;
stickyRegexp.lastIndex = 3;

str.match(regexp);
// ["nice", index: 7, input: "Have a nice day!", groups: undefined]
str.search(regexp);
// 7

str.match(stickyRegexp);
// null

stickyRegexp.lastIndex = 7;
stickyRegexp.lastIndex;
// 7

str.match(stickyRegexp);
// ["nice", index: 7, input: "Have a nice day!", groups: undefined]

str.match(stickyRegexp);
// null
stickyRegexp.lastIndex;
// 0

```

The property `lastIndex` is single-use and `Read-only`.
Therefore, if it was used for a single scan, the value is initialized.

If flag `y` and `g` are used together, flag `g` is ignored and it is recommended to be used alone.
Also, it has started to be supported relatively recently, so please check and use browser support.

## Regular Expression Pattern (Expression)

Various special symbols (patterns) of expressions are not recognized by matching the meaning (function) of the symbol, so if you don`t memorize them separately, you can`t understand the meaning.
First, I organized the basic meanings in the table below.

<table><thead><tr><th>Regular expression pattern</th><th>Description</th></tr></thead><tbody><tr><td><code>`^`</code></td><td>match at start of line, <code>`/^abc/`</code></td></tr><tr><td><code>` $`</code></td><td>match at end of line, <code>`/xyz$/`</code></td></tr><tr><td>< code>`.`</code></td><td>match any single character</td></tr><tr><td><code>`a|b`</code></td><td>match a or b, return the smaller index first</td></tr><tr><td><code>`*`</code></td><td>0 times Matches as many times as possible with more than one repeated character, same as <code>`{0,}`</code></td></tr><tr><td><code>`*?`</code>
</td><td> Match zero or more consecutive characters and as few as possible (lazy), same as <code>`{0}`</code></td></tr><tr><td><code>`+`</code></td><td>matches as many characters as possible, one or more consecutively repeated, same as <code>`{1,}`</code></td>
</tr><tr><td><code>`+?`</code></td><td> Match as little as possible (lazy) to a character repeated one or more times in a row, <code>`{ Same as 1}`</code></td></tr><tr><td><code>`?`</code></td><td>matches none or as many times as possible</td> </tr><tr><td><code>`??`</code></td><td>matches none or as few times as possible (lazy)</td></tr><tr><td>
<code>`{3}`</code></td><td>3 (number) consecutive matches</td></tr><tr><td><code>`{3,}` </code></td><td>3 or more consecutive matches</td></tr><tr><td><code>`{3,5}`</code></td><td>3 or more 5 or less (3-5) consecutive matches</td></tr><tr><td>
<code>`{3,5}?`</code></td><td>3 or more 5 or less (3-5) as few as possible 3 consecutive matches (lazy), <code> Same as `{3}`</code></td></tr><tr><td><code>`()`</code></td><td>Group to be captured</td></tr><tr><td><code>`(?&lt;&gt;)`</code></td><td>Name the capture group, <code>`/(?&lt; name&gt;pattern)/`</code> <strong>ES2018</strong></td></tr><tr><td><code>`\1~9`</code></td><td>Refer to captured value within regular expression, <code>`/(abc)\1/`</code></td></tr><tr><td><code>`(?:)`</ code></td><td>Group not to capture</td></tr><tr><td><code>`(?=)`</code></td><td> Lookahead, <code>`/ab(?=c)/`</code></td></tr><tr><td><code>`(?!)`</code> </td><td>Negative Lookahead, <code>`/ab(?!c)/`</code></td></tr><tr><td><code>` (?&lt;=)`</code></td><td>Lookbehind, <code>`/(?&lt;=ab)c/`</code> <strong>ES2018</strong>
</td></tr><tr><td><code>`(?&lt;!)`</code></td><td>Negative Lookbehind, <code>`/ (?&lt;!ab)c/`</code> <strong>ES2018</strong></td></tr><tr><td><code>`[abc]`</code></td><td>a Or matches b or c, special characters such as dot (<code>`.`</code>) or asterisk (<code>`*`</code>) are inside <code>`[]`</code> Not a special character, <code>`/\.[.]/`</code></td></tr><tr><td><code>`[az]`</code></td>
<td>matches character range a through z (lowercase English)</td></tr><tr><td><code>`[AZ]`</code></td><td> Matches the range of letters A through Z (uppercase English)</td></tr><tr><td><code>`[0-9]`</code></td><td>from 0 Matches between 9 characters (number)</td></tr><tr><td><code>`[Ga-hit]`</code></td><td> Matches to character segment (Korean)</td></tr><tr><td><code>`[2-7]`</code></td><td> Matches to character segment from 2 to 7 Match(2,3,4,5,6,7)</td></tr><tr><td><code>`[bf]`</code></td><td> from b to f Matches between character segments (b,c,d,e,f)</td></tr><tr><td><code>`[many-bar]`</code></td><td>matches the character range between da to bar (da, la, ma, ba)</td></tr><tr><td><code>`[^abc]`</code></td>
<td>match any character other than a or b or c (negative)</td></tr><tr><td><code>`\`</code></td><td>Escape Character, <code>`/\.\?\/\$\^/`</code></td></tr><tr><td><code>`\b`</code></td><td>a boundary matching any other character that is not 63 characters (52 upper and lower case letters + 10 numbers + <code>`_`</code>(underscore))</td></ tr><tr><td><code>`\B`</code></td><td>Boundary matching 63 characters</td></tr>
<tr><td><code>`\d`</code></td><td>Match Digit</td></tr><tr><td><code>`\ D`</code></td><td>matches non-numeric characters</td></tr><tr><td><code>`\p{}`</code></td> <td>matches any character that matches a set of Unicode properties, <code>`/\p{Emoji}/u`</code> <strong>ES2018</strong></td></tr><tr><td><code>`\P{}`</code></td><td> Matches any character that does not fit in the Unicode property set, <code>`/\p{Uppercase}/u`</code> <strong>ES2018</strong></td></tr><tr><td><code>`\s`</code></td><td>space (Space, Tab, etc.) Matches on</td></tr><tr><td><code>`\S`</code></td><td>matches non-space characters</td></tr><tr>
<td><code>`\w`</code></td><td>63 characters (Word, 52 upper and lower case letters + 10 numbers + <code>`_`</code>) Matches</td></tr><tr><td><code>`\W`</code></td><td>matches any character other than 63 characters</td></tr> <tr><td><code>`\x`</code></td><td>matches hexadecimal character, <code>`/\x61/`</code> is <code>`a` Matches </code></td></tr><tr><td><code>`\0`</code></td><td>matches octal characters, <code>`/\ 141/`</code> matches <code>`a`</code></td></tr><tr><td><code>`\u`</code></td><td>matches Unicode characters, <code>`/\u0061/`</code> matches <code>`a`</code></td></tr><tr><td>
<code>`\c`</code></td><td>matches Control character</td></tr><tr><td><code>`\f`</code></td><td>Form feed (FF, U+000C) Match any character</td></tr><tr><td><code>`\n`</code></td><td>match a line feed (LF, U+000A) character</td>
</tr><tr><td><code>`\r`</code></td><td>match carriage return (CR, U+000D) character</td></tr><tr><td><code>`\t`</code></td><td>match tab (U+0009) characters</td></tr><tr><td><code>` $``</code></td><td>Refer to previous value of matched character when replacing character</td></tr><tr><td><code>`$'`</code>
</td><td>Refer to value after matched character when replacing character</td></tr><tr><td><code>`$+`</code></td><td>Refer to the last captured value when replacing characters</td></tr><tr><td><code>`$&amp;`</code></td><td>Replace characters ( When replacing), refer to the entire matched character result</td></tr><tr><td><code>`$_`</code></td><td>When replacing characters (input See all) characters</td></tr><tr><td><code>`$1~9`</code></td><td>Captured value when replacing characters References</td></tr></tbody></table>


 

It will be helpful to study if you keep referring to the table.

Below, we will focus on frequently used or important patterns.

Specify the following common string to use in each expression cleanup below:
Please refer to the LoremIpsum page for the sentence.
And let`s test it at https://regex101.com/.

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_1.jpg)

### Pattern ^ (Match at the beginning of line)

`^` means the starting point of the line.

```js
/^lorem/gi

```

To give you a quick look at the example above,
An expression to search for a pattern with the letter `lorem` after `^`.
Use flags `g` and `i` to search across strings without case distinction.
You will get the following results:

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_2.jpg)

### Pattern $ (match at end of line)

`$` means the end point of the line.

```js
/ipsum$/gi

```

If you search with the example above, nothing is detected.
Because the actual sentence ends with `Ipsum.` (There is a period).
Therefore, you should write:

```js
/ipsum\.$/gi

```

where `.` has a special meaning within a regular expression (matching an arbitrary character) and cannot be used simply as a term of a period.
Therefore, put a `\` (back slash) on the front.
The reasons for attaching the backslash are as follows:

> The backslash located in front of special characters indicates that the following characters are not special and should be interpreted literally.

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_3.jpg)

### Pattern. (Match any one character)

I saw it from above, ".` is not used to mean periods (use `\.` to mean periods)
Pattern `.` means any one character.

```js
/./gi

```

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_4.jpg)

All characters (including special symbols, spacing, etc.) are selected because `.` means any one character.

```js
/r./gi

```

A total of two characters (2 characters) starting with `r` and containing any one character are retrieved due to the flag `g`.

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_5.jpg)

### Pattern a|b (matching a or b)

Search by `or` condition.
`a|b` also searches for `a` and `b`.

```js
/of|te/gi

```

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_6.jpg)

When the flag `g` is removed:
The index of the retrieved results returns the smallest (most consistent) value because the flag `g` does not exist and is not a global search.

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_7.jpg)

### Pattern * (matches as many characters as possible that are repeated more than 0 times in a row)

```js
/ing*/gi

```

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_8.jpg)

Search for `in` and `g` matches as many characters as possible that are repeated 0 or more times in a row.
In other words, `g` is searched for 0 times (not included) or several times in a row.

For example
`"in" contains (not included) 0 times of `g`.
`ing` includes `g` once.
`ing` includes `g` twice.
`ingggggggggg` contains `g` 10 times.
Therefore, `in`, `ing`, `ing`, `ingg`, and `ingggggggggggg` are all searched.

> The concepts 'matching as much as possible' and 'matching as little as possible' do not imply the number of character arrays (results) discovered.
Let's take a closer look from the back.

> If you don't understand "Advanced!", move on!

First, let`s look at the following example.
Let`s be careful that there is no flag `g`!

```js
"abccc".match(/c*/);
// ["", index: 0, input: "abccc", groups: undefined]

```

![image](https://heropy.blog/images/screenshot/regexp_homemade_exam_1.jpg)

where the expression `c*` contains the letter `c` 0 times (not including) or repeatedly, the matching condition is satisfied.
Therefore, the string you want to search for, `abccc`, followed by the first letter `a` (empty string, starting point), is output as the return value of `.match()` because it meets the matching condition `0 times` including `c` (0 times.

```js
"ccabccc".match(/c*/);
// ["cc", index: 0, input: "ccabccc", groups: undefined]

```

![image](https://heropy.blog/images/screenshot/regexp_homemade_exam_2.jpg)

Let`s look at the next example.

```js
"ccacc".match(/c*/g);
// ["cc", "", "cc", ""]

```

Here, we used the flag `g` to return all matching results to the array.
The returned array value contains a `"" (empty string).
This is because pattern `*` has a matching condition of `0` including `c` or `0 times`.
This means that the conditions for retrieving the start point, end point, and middle ```` (empty string) of the string are met.

```js
"ccacc".match(/d*/g);
// ["", "", "", "", "", ""]

```

At first glance, there seems to be no matching results, but it is the same as described above.
Although there are no conditions that match the expression `d` of `d*` in the string `ccacc`, the value `""" will return all of the `"" in the middle of the character including the start and end points" condition.

### Pattern *? (Match as little as possible with characters that repeat more than 0 consecutive times)

```js
/pass*/gi

```

In order to match as much as possible, `*` is searched including `s` that match `pas` more than 0 times.
Therefore, the `pass` is retrieved as follows:

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_10.jpg)

```js
/pass*?/gi

```

However, the pattern `*?` does not include `s` that match `pas` more than 0 times to match as little as possible.
Therefore, `pas` is retrieved as follows:

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_9.jpg)

### Pattern + (Match as many characters as possible that are repeated more than once in a row)

Pattern `*` was scanned (more than 0 times) without including matching characters.
However, in the case of `+`, it must contain at least one matching character.
Check the difference in the following example.

```js
/dum*/gi

```

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_11.jpg)

```js
/dum+/gi

```

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_12.jpg)

In case of pattern `+`, at least one must be included, so search for characters with at least one `m` in `du`.
Therefore, `du` does not match, but `dum`, `dumm`, `dummmmmm` and `dummmmmmmm` can be searched by matching.

### Pattern +? (Match as little as possible to characters that repeat more than once in a row)

Pattern `+` and `+`?It has the same difference between `do` pattern `*` and `*?`.

```js
/dum+?/gi

```

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_13.jpg)

Search for the least matching character with at least one `m`.

### Pattern? (None or match as many times as possible)

```js
/ble?/gi

```

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_14.jpg)

Search for `bl` and `e` for missing (not containing) or matching characters once (only containing one).
It matches with `e` because it tries to match as much as possible.
If you try to match as little as possible, you won`t include `e`?!

### Pattern ? (None or match as little as possible)

```js
/ble??/gi

```

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_15.jpg)

Now do you understand the difference between `as much as possible` and `as little as possible`?

### Pattern {0} (continuous match)

Pattern `{}` is pattern `*`, `*?`, `+`, `+`?It`s easy to think of it as an extension of ``.
Unlike the above method, where `0 or more` and `1 or more` are all, you can set the number of consecutive numbers by putting them directly.

Look at the following table and compare it to the patterns you saw above.

<table><thead><tr><th>Regular expression pattern</th><th>Description</th></tr></thead><tbody><tr><td><code>`*`</code></td><td>matches 0 or more consecutive characters as many times as possible, same as <code>`{0,}`</code></td></tr><tr><td><code>`*?`</code></td><td> Matches characters repeated 0 or more times and as little as possible (lazy), same as <code>`{0}`</code> </td></tr><tr><td><code>`+`</code></td><td> Matches as many characters as possible, one or more consecutively repeated characters, <code>`{1 Same as ,}`</code></td></tr><tr><td><code>`+?`</code></td><td>For characters repeated more than once Match as few as possible (lazy), same as <code>`{1}`</code></td></tr><tr><td><code>`{3}`</code></td>
<td>3 (number) consecutive matches</td></tr><tr><td><code>`{3,}`</code></td><td>3 or more consecutive matches </td></tr><tr><td><code>`{3,5}`</code></td><td>3 or more and 5 or less (3-5) consecutive matches</td></tr><tr><td><code>`{3,5}?`</code></td><td>3 or more and 5 or less (3-5) Enemy 3 consecutive matches (lazy), same as <code>`{3}`</code></td></tr></tbody></table>


 

```js
/pas{0,1}/gi

```

![image](https://heropy.blog/images/screenshot/regex101.com_screenshot_16.jpg)

### Pattern () (Group to Capture)

The pattern `()` can be difficult because it has many different meanings as well as simple meanings of grouping (grouping).
First, let`s take a look at the easy grouping concept.

Group part of the expression into a pattern `()` and group its contents into a single result.
Compare the grouped results with those that are not.

```js
const ko = 'kokokoko';
const koooo = 'kooookoooo';

ko.match(/ko+/);
// ["ko", index: 0, input: "kokokoko", groups: undefined]
koooo.match(/ko+/);
// ["koooo", index: 0, input: "kooookoooo", groups: undefined]

ko.match(/(ko)+/);
// ["kokokoko", "ko", index: 0, input: "kokokoko", groups: undefined]
koooo.match(/(ko)+/);
// ["ko", "ko", index: 0, input: "kooookoooo", groups: undefined]

```

The expression `ko+` searches for `k` and `o` searches for repeated characters at least once in a row.
As a result, `kooo` was returned.

However because expression `(ko)+` combines `k` and `o` (grouping), `ko` is searched as repeated characters at least once in a row.
Therefore, the result was returned as `kokokoko`.

It`s not hard to group, is it?

Finally, if you look at the results of regular expressions using pattern `(), there are two matching results.
How did we get two results when we didn`t use the flag `g`?

The pattern `()` captures and uses the expressions in parentheses.
Capture is a concept that creates a kind of copy.

> The word copy is used only for understanding, and it is different from the actual concept.

Let`s take a look at the following expressions in the above example above.

```js
ko.match(/(ko)+/);
// ["kokokoko", "ko", index: 0, input: "kokokoko", groups: undefined]

```

Group and capture the `"ko" in the pattern `().
First of all, captured expressions are not used immediately, and the grouped `ko` is searched as a repeated character more than once in a row with the pattern `+`.
After all the non-capture expressions work, the expression `ko` that was copied (captured) is retrieved.
To organize the search order:

- Search grouped `ko` with pattern `+` at least once in a row and return `kokokoko`
- Search with captured `ko` and return `ko`.

Let`s look at another example.

```js
'123abc'.match(/(\d+)(\w)/);
// ["123a", "123", "a", index: 0, input: "123abc", groups: undefined]

```

> Capture takes place from outside to inside, and from left to right.

There`s a pattern that we haven`t looked at yet.
`\d` corresponds to a number, and `\w` corresponds to 63 characters (52 uppercase letters + 10 numbers + `_`(underscore).
Simply put, a pattern of searching for numbers and letters (including numbers).
Let`s move on as I explain it again from the back.

The search order is as follows:

- Capture expressions in the pattern `()` in order. `\d+`, `\w`
- Search with remaining expressions after capture.
- Search for a number with pattern `\d`, but match at least one consecutive number with pattern `+`. `"123"`
- The next pattern `\w` matches `a` when searching for characters.
- This returns `123a`.
- Search for a number with the first captured expression `\d+`, but match one or more consecutive numbers with the pattern `+`. `"123" is returned as a match.
- The next captured expression, `\w`, is searched for a character, and `"a" is returned with a match.

We explained above that capture is a kind of copy.
Such captured (copied) values can be referenced within a regular expression in a total of nine patterns, from `\1` to `\9`.
It is the same concept as assigning values to variables such as `var abc = "abc"; and referring to values by the name of variables.

```js
"aabbcc".match(/(a)\1/);
// ["aa", "a", index: 0, input: "aabbcc", groups: undefined]

```

Capture `a` with pattern `().
Since the expression `/1` refers to the captured `a` in the remaining expression, the expression is equal to `/aa/`, and the corresponding value is searched and `aa` is returned.
It then searches for a value that matches the captured `a` and returns `a`.

Analyze the following examples directly with the same concept.

```js
"aabbbcc".match(/((b))\1\2/);
// ["bbb", "b", "b", index: 2, input: "aabbbcc", groups: undefined]

```

The captured values can be referenced in a total of nine patterns, from `$1` to `$9` when replacing characters in .replace() outside the regular expression.

```js
"hello.world".replace(/(\w+)\.(\w+)/, "$2.$1");
// "world.hello"

```

This is an example of changing the position of the words `hello` and `world` in the sentence `hello.world`.

The matching characters found through the regular expression are `hello.world` and the value captured by the pattern `()`.
This is `hello` captured as the first `\w+` and `world` captured as the second `\w+`.
Each captured value can be referenced as `$1` for the first and `$2` for the second.
Since the referenced value is replaced by `$2.$1`, `world` is inserted in `$2` where `world` is `hello` in `$1` and `world.hello` is returned.

> If you don't understand "Advanced!", move on!

Some of the patterns we`ve seen above have the concept of `zero or more matches`.
`|`, `*`, `*?`, `?`, `??`, `{0}`, `{0,}`

Are these patterns `()?If it is stuck after the pattern `()` as shown in , it creates an optional capture group.
Note that optional capture groups return `undefined` as a result of not retrieving them!

Let`s look at the following example.

```js
"abc".match(/(b)?/);
// ["", undefined, index: 0, input: "abc", groups: undefined]

```

As a result, ```` and `undefined` were returned.
We looked at the `Advanced! Optional pattern` of pattern *` having a matching condition of `0 inclusive` or `0 times satisfies the condition to search for the "" (empty string) between the start point, end point, and the middle of the character.
Therefore, because the empty string ```` matches first and then the captured ``b`` is retrieved, the retrieved result does not exist and `undefined` is included in the array slot.

```js
"ab".match(/(b)?(a)/);
// ["a", undefined, "a", index: 0, input: "ab", groups: undefined]

"ab".match(/(b)?(a)(b)/);
// ["ab", undefined, "a", "b", index: 0, input: "ab", groups: undefined]

"abc".match(/(b)?(a)?(c)?(b)?/);
// ["ab", undefined, "a", undefined, "b", index: 0, input: "abc", groups: undefined]

```

![image](https://heropy.blog/images/screenshot/regexp_homemade_exam_3.jpg)

All optional capture groups have the same results:

```js
"football".match(/(ball)|(foot)/);
"football".match(/(ball)*(foot)/);
"football".match(/(ball)*?(foot)/);
"football".match(/(ball)?(foot)/);
"football".match(/(ball)??(foot)/);
"football".match(/(ball){0}(foot)/);
"football".match(/(ball){0,}(foot)/);

// ["foot", undefined, "foot", index: 0, input: "football", groups: undefined]

```

### Specify Pattern (?<>) Capture Group Name

As a result of many examples, we have seen that the results include the attribute `groups` as follows:

```js
"aabbcc".match(/(a)/);
// ["a", "a", index: 0, input: "aabbcc", groups: undefined]

```

This property is a group that stores captured results and is not available until you specify a name.
Capture group pattern `()` in front of the inner `?You can specify the name of the capture group by creating it, such as <Name>.

```js
const result = "aabbcc".match(/(?<myName>a)/);
// ["a", "a", index: 0, input: "aabbcc", groups: {myName: "a"}]

console.log(result.groups.myName);
// "a"

```

`groups` is of type `object`, so name it using `camelCase` notation.

```js
"aabbcc".match(/(?<my-name>a)/);
// Uncaught SyntaxError

```

> Pattern '(?<)' is a new feature in ECMAScript 2018.
Check compatibility when using!

### Pattern (?:) (Uncaptured Groups)

The capture group pattern `()` can be more difficult to handle than you think because it has many meanings, such as non-grouping capture.
Therefore, you can use a pattern `(?:)` that has only the grouping meaning of the expression.

The pattern looks complicated, but the meaning is very simple.
Use `?:` in front of pattern `()`.

```js
const ko = 'kokokoko';

ko.match(/(ko)+/);
// ["kokokoko", "ko", index: 0, input: "kokokoko", groups: undefined]

ko.match(/(?:ko)+/);
// ["kokokoko", index: 0, input: "kokokoko", groups: undefined]

```

Because it does not capture expressions, it searches only with `ko` that group `k` and `o`.

### Pattern (?=) (Front Matching)

Pattern `(?=)` means that the expression in front of it must be in front of the character matching the expression in the pattern (`(?=here`)`.

The following example returns `ab` as a result because the expression `ab` located in front of the pattern `(?=)` is in front of the expression `c`.
where `(?=c)` is just a condition for searching for the expression that precedes it.
This means that `ab` must be searched, followed by `c` to match.

```js
"abc".match(/ab(?=c)/);
// ["ab", index: 0, input: "abc", groups: undefined]

"abd".match(/ab(?=c)/);
// null

```

Because it searches for expressions in front of the pattern, like the word `forward matching`, reordering returns a completely different result.
The next first example will match the expression `c` (empty string) in front of the expression `c` in the pattern and then search for `ab`, so there will be no matching results.

```js
"abc".match(/(?=c)ab/);
// null

"abc".match(/(?=c)/);
// ["", index: 2, input: "abc", groups: undefined]
`

```

### Pattern (?!) (Negative Front Match)

Pattern `(?!)` has the negative meaning of pattern `(?=).

```js
"abc".match(/ab(?!c)/);
// null

"abd".match(/ab(?!c)/);
// ["ab", index: 0, input: "abd", groups: undefined]

```

### Pattern (?=) (Back Matching)

Pattern `(?=)` means that the expression located behind it must be behind the character matching the expression in the pattern.
It would not be difficult if you understood the `front match(?=)``.

```js
"xyz".match(/(?<=x)yz/);
// ["yz", index: 1, input: "xyz", groups: undefined]

"ayz".match(/(?<=x)yz/);
// null

```

### Pattern (?<!) (Negative Back Match)

The pattern `(?<!)` has the negative meaning of the pattern `(?=).

```js
"xyz".match(/(?<!x)yz/);
// null

"ayz".match(/(?<!x)yz/);
// ["yz", index: 1, input: "ayz", groups: undefined]

```

### Pattern [abc] (matching a or b or c)

The characters in the pattern `[]` each have the meaning of `or`.
Therefore, the expression `[abc]` is the same as `a|b|c`.

```js
"abc".match(/[bca]/);
// ["a", index: 0, input: "abc", groups: undefined]

"abc".match(/b|c|a/);
// ["a", index: 0, input: "abc", groups: undefined]

```

The result is `a` because the index returns the smallest value (most matched) such as the pattern `|`.

```js
const str = "character class or charectar set";
str.match(/char[ae]ct[ae]r/g);
// ["character", "charectar"]

```

It can also be useful when searching for words that contain the above and the wrong characters.

Using `-` within the pattern `[]` allows you to specify a range of characters (intervals).

```js
"abcdef".match(/[a-e]/);
// ["a", index: 0, input: "abcdef", groups: undefined]

"abcdef".match(/[abcde]/);
// ["a", index: 0, input: "abcdef", groups: undefined]

"abcdef".match(/[a-e]/g); // flag 'g'
// ["a", "b", "c", "d", "e"]

"01234567890".match(/[1-0]/); // SyntaxError

"01234567890".match(/[0-9]/)
// ["0", index: 0, input: "01234567890", groups: undefined]

"01234567890".match(/[0-9]/g)
// ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]

"Ganada Ramabasaa."match(/[multi-bar]/[ga-hit] Korean character interval
// ["Da", "La", "Ma", "Bar"]

/[ðŸ˜€-ðŸ˜‡]/u.test ("ðŸ˜‚"); // Unicode character interval
// true

```

Within the pattern `[]`, you can use it without putting `\` in front of special characters.

```js
"Hmm....".match(/\.[.]/);
// ["..", index: 3, input: "Hmm....", groups: undefined]

```

The pattern `.` means `any letter`, but it is a simple period.If you want to use ``, you can use `\` in front of it.
However, if it is used within a pattern `[]`, it does not need `\`.It can be used as `

### Pattern [^abc] (matches other characters other than a or b or c)

Pattern `[^]` has the opposite (negative) meaning of pattern `[]`.
The expression `[^abc]` searches for the other characters except `a|b|c`.

```js
"abcd".match(/[^bca]/);
// ["d", index: 3, input: "abcd", groups: undefined]

```

`"d" was returned because it corresponds to the rest of the characters except `b`, `c` and `a`.

```js
"hello123 world456".replace(/[^\d]/g, "");
// "123456"

```

In the character `hello123 world456`, find all the characters except the number (`\d`) to the flag `g` and convert them to an empty string (`"`).
You can use the opposite of the pattern `\d` (matching non-numeric characters) that matches the number by returning the same result.

```js
"hello123 world456".replace(/\D/g, "");
// "123456"

```

# Example of a regular expression

If there is a good example from a line that is not too complicated, I will continue to add it.
If you have a good example to recommend, please leave a comment.

## Insert variables into regular expressions

We use `RegExp` object to put variables in regular expressions.

```js
new RegExp(`{${minNum},${maxNum}`)

```

## Extract value between parentheses

Be careful not to use the `g` flag.

```js
const str = 'Heropy(Young-Woong Park)'
str.match(/\((.*)\)/)[1] // Young-Woong Park

```

# References

https://www.asciitable.com/
https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/%EC%A0%95%EA%B7%9C%EC%8B%9D
https://flaviocopes.com/javascript-regular-expressions/
https://javascript.info/regexp-groups
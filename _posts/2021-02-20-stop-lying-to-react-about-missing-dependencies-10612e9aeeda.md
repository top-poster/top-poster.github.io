---
layout: post
title: "누락된 종속성에 대한 대응을 위한 거짓말 중지"
author: "Logger"
thumbnail: "undefined"
tags: 
---


![Question mark scribbled on paper](https://miro.medium.com/max/11232/0*lePWxZCY5e8L0_Tu)

`use Effect`를 사용해 본 적이 있다면 다음과 같은 보풀 경고를 받게 될 것입니다.

```js
반응 후크 사용 효과의 종속성이 누락되었습니다. 종속성 배열을 포함하거나 제거합니다.
```

때로는 필요한 종속성을 추가하는 것만큼 간단하지만, 종종 이것은 예상치 못한 행동을 초래하여 머리를 긁적거리게 합니다. 게다가 API를 다운받기 전에 브라우저 탭을 필사적으로 닫으려 할 때 무한 루프에 갇힐 수도 있습니다.

그렇다면 우리는 이 경고를 그냥 무시하지 않고 어떻게 적절하게 대처할 수 있을까요?

TL;DR: 솔루션을 찾고 계신다면 "Dependency Array 문제 해결" 섹션으로 바로 건너뛸 수 있습니다.

React Hooks의 등장으로 `use Effect`는 이전에 구성요소 클래스(예: `componentDidMount` 또는 `componentWillUpdate`)에서 액세스할 수 있었던 라이프사이클 방법을 처리하는 방법으로 인식되어 왔다. 현실은 조금 더 미묘하며 객체 지향 프로그래밍에서 벗어나 기능적 프로그래밍으로 사고하는 전환이 필요하다.

위키백과에 따르면:

React의 맥락에서, 순수한 기능적 구성요소는 소품(인수)을 취하고 일부 컨텐츠를 렌더링하는 구성요소이다. 동일한 소품으로 구성 요소를 렌더링하면 항상 동일한 HTML이 출력됩니다. 구성 요소는 내부 상태를 갖지 않으며 외부 변수와 상호 작용하거나 수정하지 않습니다.

이는 프레젠테이션 구성 요소에는 좋지만 실제 상황에서는 (예를 들어 API에서 일부 데이터를 로드하거나 렌더링 간에 일부 상태를 유지하기 위해) 부작용이 필요한 경우가 있을 것이다. 여기가 리액트 훅스가 들어오는 곳이야.

그렇다면 use Effect는 실제로 어떤 역할을 할까요? 음, 이름에서 알 수 있듯이, 이것은 부작용을 다루는 방법입니다. 종속성의 배열이 필요하며, 마지막 렌더 이후 종속성이 변경된 경우 사용자가 제공하는 함수를 실행합니다. 즉, 구성 요소가 다시 렌더링될 때마다가 아니라 원하는 경우에만 API에서 데이터를 로드하는 등의 작업을 처리할 수 있습니다.

참고: 후드 아래에서 작동하는 방식에 관심이 있는 경우, Retact는 구성 요소의 후크 순서에 따라 렌더링 간에 부작용을 처리하는 방법을 알고 있으므로 상위 레벨에서만 후크를 호출할 수 있습니다. 자세한 내용은 설명서를 참조하십시오.

그러나 이러한 종속성 배열은 종종 문제를 일으킵니다. 마운트 시 한 번 효과를 실행하려면 빈 종속성 배열을 사용할 수 있습니다. 예를 들어 구성 요소가 다음을 렌더링할 때 `axios`를 사용하여 일부 데이터를 가져오려고 합니다.

여기에서 보풀 경고가 발생합니다.

```js
React Hook useEffect에 'params'라는 종속성이 없습니다. 종속성 배열을 포함하거나 제거합니다.
```

이 경고는 무엇을 의미합니까? use Effect 안의 코드는 API 요청을 하기 위해 params 변수에 의존하고 있다. 구성 요소가 다시 렌더링되면 사용 효과 내의 매개 변수 값이 구식이 될 수 있습니다. 효과는 한 번만 실행되기 때문에 첫 번째 렌더링 시 params 값만 갖게 된다.

콘솔에 나타나는 성가신 보풀 경고 외에도 이것이 정말 문제인지 궁금할 수 있습니다. 이 경우 코드가 예상대로 작동하고 문제가 없습니다. 그러나 올바른 종속성을 포함하지 않으면 해결해야 할 악몽이 될 수 있는 미묘한 버그가 발생할 가능성이 있다.

Dan Abramov는 A Complete Guide to use Effect(이펙트 사용)라는 게시물에서 다음 간격으로 카운터 앱의 예를 사용합니다.

실행 간격을 한 번만 설정하려고 하지만 효과의 종속성 배열의 일부로 `카운트`가 없기 때문에 기본값(이 경우 `0`)만 가집니다. 1초 후에 1로 증가했다가 간격의 각 인스턴스에서 카운트를 0 + 1로 설정하기 때문에 변하지 않는 0이 표시됩니다.

아브라모프의 말대로:

따라서 `use Effect`의 첫 번째 일반적인 문제는 탑재 시 한 번만 실행하려고 할 뿐 보풀 경고에 부딪히고 있다는 것입니다. 하지만 우리가 예를 들어 설명할 수 있는 또 다른 문제가 있다.

사용 효과의 종속성 배열에 "params"를 추가하여 보풀 경고를 해결할 수 있습니다.

이론적으로, 이것은 효과가 있을 것이다. 파라미터는 변경되지 않으므로 탑재 시 사용효과는 한 번만 실행해야 한다. 그러나 params가 개체인 경우에는 params가 동일하더라도 구성 요소를 다시 렌더링할 때마다 use Effect가 실행된다는 것을 알게 된다.

이 문제는 JavaScript에서 개체 동일성을 처리하지 않기 때문에 발생합니다.

```js
{some: 'value'} === {some: 'value'} = false
```

effect에서 종속성이 변경되었는지 확인할 때 params는 이전 값과 절대 같지 않으므로 effect 내부의 코드가 실행됩니다.

이것은 우리의 코드가 꽤 고약한 무한 루프에 갇히는 결과를 초래할 수 있습니다. 그렇다면 어떻게 이 두 가지 문제를 해결할 수 있을까요?

# 종속성 어레이 문제 해결

항상 그렇듯이, 이와 같은 문제에 직면했을 때 가장 먼저 해야 할 일은 한 걸음 뒤로 물러서 스스로를 구석으로 코드화했는지 확인하는 것입니다. 여러분이 한 일을 재구성하는 데 약간의 시간을 들이면 종종 문제에 대한 간단한 해결 방법이 있습니다. 예를 들어, 구성 요소에서 API 호출을 해야 합니까? 아니면 해당 코드를 분리하여 데이터를 소품으로 전달해야 합니까?

한 발짝 물러서서 어떤 관점을 취하는 것은 종종 이런 문제를 완전히 피할 수 있다는 것을 의미한다.

이렇게 했는데도 `이용 효과`를 사용할 수밖에 없다면 `이용 참조`에 손을 대야 할 때다.

## 구조를 참조하십시오.

React의 useRef 후크는 렌더링 간에 변이 가능한 값을 저장할 수 있는 방법을 제공합니다. 대응 문서:

참조로 일부 코드가 실행되었는지 여부를 추적할 수 있습니다. 그렇지 않으면 실행합니다. 만약 그랬다면, 건너뛰세요. 예를 들어, 다음과 같이 보입니다.

use Effect에서는 hasFetchedData.current가 false인지 확인합니다. 만약 그렇다면, 우리는 API를 치고 ref를 true로 업데이트한다. 이는 구성 요소가 다음에 렌더링되면 hasFetchedData.current가 `true`가 되고 API 호출을 하지 않는다는 것을 의미합니다. use Effect는 모든 렌더에서 계속 실행되지만 API 호출은 한 번만 실행됩니다.

사실상, 우리는 "게이트"를 가지고 있다. 특정 조건이 충족될 때만 사용효과의 내부에서 코드를 실행해야 한다.

## 비원수 처리

위에서 설명한 대로, 종속성 배열의 비원수(예: 객체 또는 배열)는 자바스크립트가 객체 평등을 결정할 수 없기 때문에 모든 렌더에서 `use Effect`가 실행되게 할 것이다. 이를 극복하기 위해서는 `이용 효과`가 실행될 때 새로운 값과 오래된 값을 어떤 형태로든 심층적으로 비교해야 할 것이다.

즉, 종속성의 이전 값을 계속 참조해야 `use Effect`가 실행될 때 이를 새 값과 비교하고 변경 여부를 확인할 수 있습니다. 다시 한번, 심판들이 구조하러 온다. useRef를 사용하여 이전 값을 저장하고 값이 변경된 경우 use Effect 안에서 업데이트할 수 있습니다(심층 비교 기능을 사용하여 확인할 수 있습니다).

위의 예와 유사한 작업을 수행하지만 "params" 값이 변경될 때마다 데이터를 가져오려고 합니다. 종속성 배열에서 "params"를 통과시킨다고 해서 "use Effect"가 모든 리렌더에 적용된다는 것을 의미하며 이는 우리가 원하는 것이 아니다. 대신 다음과 같은 작업을 수행할 수 있습니다.

참고: 이 예에서는 `빠른 딥 동일`을 사용하지만 어떤 심층 비교 기능도 사용할 수 있습니다.

이 점을 정리해보자.

즉, API 호출은 이제 `params`가 변경될 때만 실행됩니다.

# 결론

훅스가 리액트(react)에 얼마나 패러다임의 변화를 가져왔는지를 부각시킨 것은 use Effect(이용 효과)와 협력하는 것 중 하나다. 그것은 여러분이 어떤 일이 일어나고 있는지에 대해 생각하도록 강요합니다. 그리고 이것은 종종 단순한 기능의 구현 과정을 늦출 때 좌절감을 줄 수 있습니다. Hooks로 시작할 때 Abramov의 기사를 다시 인용하려면:

하지만, 일단 여러분이 정말로 "훅스"를 생각하기 시작하면, 여러분은 그 혜택을 얻을 것입니다. 시간을 들여 상황을 정확하게 파악하면 궁극적으로 더 깨끗하고 성능이 뛰어난 코드를 작성할 수 있습니다.

이러한 보풀 규칙은 이유가 있기 때문에, 우리 모두 최선을 다해 따라야 하며, 의존성에 대한 대응에 대한 거짓말은 그만두어야 합니다.
---
layout: post
title: "Redux, 컨텍스트 또는 Recil: 어떤 것이 최신 웹 앱에 가장 적합합니까?"
author: "Logger"
thumbnail: "https://cdn-images-1.medium.com/fit/t/1600/480/0*Do_eAEGfGTTF6yAC"
tags: 
---


![code on a computer screen](https://miro.medium.com/max/11982/0*Do_eAEGfGTTF6yAC)

글로벌 국가 관리의 모래가 끊임없이 이동하면서 어떤 옵션을 선택해야 할지 알 수 없습니다. Redux는 오랫동안 선택된 라이브러리였지만, React 자체에 상태 관리를 제공하는 Context API로 인해 많은 사람들이 Redux가 죽었다고 선언하고 있다. 그리고 이제 Facebook이 지원하는 초기 프로젝트인 Reachil의 릴리즈를 통해 React의 최신 기능과 쉽게 통합할 수 있는 React별 라이브러리를 갖게 되었습니다.

하지만 어떤 것이 당신의 프로젝트에 가장 적합할까요? 이 기사에서는 간단한 응용 프로그램을 각 라이브러리에 통합하고 몇 가지 비교 및 관찰 결과를 제공하려고 합니다. 이것은 단지 제 의견일 뿐입니다. 저는 절대 제 연구 결과를 사실로 제시하지 않고 있으며, 궁극적으로는 모든 사람들이 개인적인 선호도를 가질 것입니다. 하지만 저는 가능한 객관적이 되도록 노력하고 성능에 대한 경험적 비교를 제시하겠습니다.

TL;DR — 여기에서 최종 코드를 확인할 수 있습니다(각 통합은 서로 다른 분기에 있습니다). https://github.com/jogilvyt/redux-context-recoil

# 응용 프로그램

삭제할 수 있는 항목의 목록과 새로운 항목을 추가할 수 있는 양식을 렌더링하는 간단한 응용 프로그램을 만들었습니다. setTimeout이 있는 모의 API를 호출하여 결과를 가져오고, 새 항목을 생성하고, 목록에서 항목을 제거합니다.

![screen showing user choices in a basic to-do list app](https://miro.medium.com/max/1772/1*9imOvqb2mmuZDhWN6IUQew.png)

성능을 측정하기 위해 글로벌 상태 관리가 전혀 없는 상태에서 시작했습니다. 앱을 로드할 때 렌더링이 총 3개였는데, 로드 화면의 초기 렌더링은 5.3ms, 항목을 로드한 후 렌더링하는 데 7ms가 걸렸습니다.

![screenshot showing rendering times with no global state management](https://miro.medium.com/max/4628/1*YYyjFKSbQM6R342QY9Mg2A.png)

이 애플리케이션은 매우 단순하기 때문에 성능 차이가 크지 않을 것이며, 보다 복잡한 애플리케이션에서는 상황이 다르게 나타날 수 있습니다. 그러나 이를 통해 각 라이브러리의 성능에 대한 매우 높은 수준의 정보를 얻을 수 있습니다.

# 시작하기 전에

새로운 프로젝트에서는 항상 작업에 적합한 툴을 사용하는 것이 중요하므로, 이제는 글로벌 상태 관리가 실제로 필요한지 자문해 보는 것이 좋습니다. 많은 간단한 응용프로그램은 외부 라이브러리 또는 컨텍스트 API의 오버헤드를 모두 도입하지 않고도 완벽하게 작동하고 더 쉽게 유지관리됩니다. UI 엔지니어로서, 우리는 모든 반짝이는 새로운 툴에 무모한 포기를 가지고 편승하는 것으로 명성을 얻고 있습니다. 함정에 빠지지 마십시오. 통합하기 전에 글로벌 상태 관리 시스템이 정말로 필요한지 확인하십시오.

# 레덕스

Redux는 아마도 가장 잘 확립된 글로벌 상태 관리 도구일 것이다. 프레임워크에 구애받지 않는 것으로, 이는 프런트 엔드 세계 전체에 걸쳐 인기가 있었다는 것을 의미하며, 한동안은 로컬 상태를 넘어서야 할 때 정말로 유일한 선택이었습니다. 그러나 최근 Context API와 새로운 도전자인 Reachil이 추가되면서, Redux는 여전히 현대적인 React 앱에서 독자적인 것을 유지할 수 있을까요?

## 성과

일단 성능부터. 초기 부하에서는 기준선의 3이 아닌 2개의 렌더링만 있습니다. 그러나 전체 렌더링 시간은 약간 더 길어집니다. 로드 상태를 렌더링하려면 6ms, 항목을 가져오면 목록을 렌더링하려면 10.6ms입니다.

![screenshot showing rendering times with Redux](https://miro.medium.com/max/4624/1*QolhVTnrvYYubvoYFrJyHw.png)

새 아이템 추가 후 리렌딩은 2.9ms, 아이템 제거 후 2ms가 걸렸습니다. 전반적으로, 애플리케이션을 로드할 때 초기 오버헤드를 제외하면 성능이 상당히 빠릅니다.

## 개발자 경험

이것은 나에게 항상 Redux의 큰 단점들 중 하나였다. 작동하기 위해서는 항상 많은 보일러 플레이트가 필요하다는 느낌을 받았고, 앱을 통해 여러 개의 리듀서를 사용하면 반복에 빠지기 쉽다. 이 예에서는 스토어, 리듀서, 그리고 세 가지 동작이 있습니다. 이것은 기본적인 것에 대한 많은 코드처럼 느껴집니다.

즉, Redux는 개발자 모범 사례를 적용하는 데 능숙하여 쉽게 따를 수 있는 패턴을 제공하므로 기능을 구축할 때 구현에 대해 너무 많은 결정을 내릴 필요가 없습니다. API 요청을 추상화하여 모든 것을 한 곳에서 처리할 수 있도록 하는 방법도 마음에 듭니다. API 호출을 어디서 업데이트해야 할지 알고 있을 때, 어떤 구성 요소를 탐색하여 어떤 요청을 하는지 찾는 것보다 훨씬 쉽습니다.

## 사용자 경험

Redux를 사용하여 로드 및 오류 상태를 관리하려면 일부 사용자 지정 구현이 필요합니다. 제 경우, 저는 환원기에서 전역 `isLoading` 변수를 추적한 다음 각 구성 요소에서 항목을 추가하고 제거하기 위한 로드 상태를 관리합니다. 이것은 꽤 표준적인 물건이고 만들기도 어렵지 않지만, Recoil이 정말로 빛나는 분야 중 하나입니다. 나중에 더 많이요!

# 컨텍스트 API

새로운 Context API는 React 버전 16.3에 도입되었으며, 공통 부모에게 상태를 "호이스트"하지 않고도 구성요소 간에 상태를 공유하는 방법을 제공하기 위한 것이다. 그것은 현재 특히 사용자 정보나 테마 선호와 같은 더 많은 정적 데이터에 글로벌 상태를 저장하는 방법으로 널리 사용되고 있다. Redux와 어떻게 비교하는지 봅시다.

## 성과

제공자에서 상태가 업데이트되면 해당 구성 요소와 관련된 상태가 변경되지 않았더라도 컨텍스트를 사용하는 모든 구성 요소가 다시 렌더링되므로 성능 면에서 컨텍스트가 좋지 않다고 합니다.

응용 프로그램의 경우 로드 시 3개의 렌더러가 있었습니다. 초기 로드 상태는 5.9ms, 데이터를 가져온 후 2.9ms의 렌더링을 수행했으며 마지막으로 작업 항목을 렌더링하는 데 7.6ms가 걸렸습니다.

![screenshot showing rendering times with Context API](https://miro.medium.com/max/4632/1*SgQ6U9TlS33djJxIlHUGsQ.png)

이것은 Redux의 렌더링 시간과 대체로 비슷해 보입니다. 단, 항목 추가 또는 제거 시 항목 추가 후 다시 렌더링하는 데 걸리는 시간은 4.9ms, 제거 후 4.5ms(Redux의 경우 각각 2.9ms와 2ms 대비)로 더 높다.

## 개발자 경험

저는 이것이 바로 컨텍스트 API가 정말 빛을 발하는 부분입니다. React에 내장되어 있으므로 주요 아키텍처 변경이나 전체 라이브러리 추가 없이 글로벌 상태 관리가 필요한 경우 프로젝트를 점진적으로 도입할 수 있습니다. 나는 또한 후크와의 통합이 얼마나 쉬운지 좋아한다. 이 응용 프로그램에서 상태를 컨텍스트에서 해제하고 이를 사용하는 모든 구성 요소를 호출할 수 있는 `useToDos` 후크를 만들었습니다.

```undefined
const {toDos} = useToDos(;
```

Retact의 useReduce 후크와 통합하여 복잡한 상태를 관리할 수도 있습니다. 많은 하위 구성 요소와 복잡한 기능이 있는 구성 요소에 대해 공유 상태를 관리하는 데 매우 유용한 방법입니다.

## 사용자 경험

로드 및 오류 상태는 Redux와 매우 유사한 방식으로 처리됩니다. 각 로드 상태를 처리하기 위한 사용자 지정 코드를 작성해야 하며, API 호출을 통해 모든 오류를 처리해야 합니다. 여기서 Redux 작업에서 API 요청을 갖는 것이 유용할 수 있습니다. 컨텍스트를 사용하면 API를 호출하는 위치에 오류 처리를 추가해야 합니다. 즉, 중복 또는 리팩터링을 의미합니다.

# 반동

리코일은 이 블록에 새로 등장한 아이로, 지난해 발표 이후 다소 물의를 빚고 있다. 또한 React를 유지하는 Facebook을 통해 지원되며 동시 모드와 같은 많은 최신 React 기능과 잘 통합됩니다. 아직 개발 초기 단계이며, 아직 프로덕션 앱에서는 사용하지 않는 것이 좋습니다. 하지만 현재의 초기 형태에서, 우리가 마음대로 사용할 수 있는 다른 옵션들과 비교한다면 어떨까요?

## 성과

Recoil의 초기 부하는 세 가지 옵션 중 가장 느렸습니다. 렌더링이 총 5개로 가장 먼저 11.2ms가 소요되었으며, 그 다음으로는 약간 빠른 렌더 2개(1.1ms와 0.2ms)와 작업량이 로드되면 5ms 렌더링을 수행한 다음, 항목을 화면에 렌더링하는 최종 1.9ms가 뒤따랐다.

![screenshot showing rendering times with Recoil](https://miro.medium.com/max/4624/1*r9fOzaNwtHnTxvrF2NoArA.png)

하지만 아이템 추가와 제거는 아이템 추가 후 2.4ms, 아이템 제거 후 3.7ms로 훨씬 스냅력이 뛰어났다. 이것은 Redux와 대체로 일치하는 것 같다.

또한 React의 일부로 제공되는 Recil 패키지 크기는 Redux의 경우 11.7K에 비해 45.1K(내 Import Cost VS Code 플러그인에 따라)이며 Context의 경우 전혀 없습니다. 도서관 일이 계속되면서 이 점은 달라질 수 있지만, 명심해야 할 사항입니다.

## 개발자 경험

리코일을 처음 사용하긴 했지만, 원자와 선택기에 머리를 굴려 사용하기에 편리했다. API 요청에서 상태를 초기화하기 위해 선택기에서 비동기 요청을 할 수 있는 방법이 마음에 들었습니다.

또한 구성 요소에서 상태를 사용하는 것이 매우 쉽습니다. useState와 비슷한 방식으로 작동합니다.

```undefined
const [toDos, setToDos] = usRecoilState(toDosAtom);
```

제가 조금 헷갈리는 부분은 항목을 추가하거나 제거한 후 상태를 업데이트하는 것이었습니다. 비동기식 선택기를 사용하면 API 요청의 응답을 기반으로 상태를 업데이트하는 데 사용할 수 있는 유사한 세터 기능을 사용할 수 있다는 것이 멋질 것 같아서요. 나중에 추가될 수 있습니다. 지금은 구성 요소에서 API 호출을 수행하고 상태를 응답으로 설정합니다.

## 사용자 경험

여기가 코칠이 정말 빛나는 곳이에요. React의 동시 모드와 통합되어 `Suspense`로 로드 상태를 처리하고 `ErrorBoundary`로 오류를 처리할 수 있습니다. 이것은 당신이 훨씬 더 선언적인 방법으로 당신의 앱을 만들 수 있다는 것을 의미합니다. 예비로 지원서를 `서스펜스` 컴포넌트로 포장할 수 있었고, API 요청이 완료되고 할 일이 로딩될 때까지 자연스럽게 로딩화면이 렌더링됩니다.

이것의 한 가지 부작용은 그것이 여러분에게 건축적인 결정을 강요한다는 것입니다. Rechil을 성숙한 애플리케이션에 통합하는 것은 어려울 수 있으며, 특정 방식으로 작업을 수행하는 것을 선호하는 경우 라이브러리의 제약 조건 내에서 작업을 수행하기가 어려울 수 있습니다. 하지만, 그것은 확실히 Redux보다 더 리액티브하게 느껴진다.

# 결론

Redux는 한동안 글로벌 상태 관리의 선두 주자로 자리매김해 왔으며, 곧이어 아무 데도 진출할 수 없을 것입니다. 하지만 Context와 Reachil은 심각한 경쟁자가 되고 있으며 React와 더 잘 어울리는 것 같다.

약간의 성능 저하가 문제가 되지 않는 소규모 애플리케이션에는 컨텍스트를 사용하고 싶습니다. 더 큰 프로젝트에 대해서는, Recoil이 여전히 치아에 문제가 있다고 느끼며, 저는 아직 프로덕션 애플리케이션에 사용하는 것을 추천하지 않습니다. 그러나 시간이 흐르면 더 나은 개발자 경험과 궁극적으로는 더 나은 사용자 경험을 모두 제공할 수 있을 것으로 보입니다. React의 새로운 기능과 완벽하게 통합되는 Reachil의 모습은 매우 흥미롭고, 애플리케이션에 이러한 기능을 사용하기 시작하면서 Reachil이 글로벌 상태 관리를 위한 자연스러운 선택이 될 것이라고 생각합니다.

읽어주셔서 감사드리며, 어떤 글로벌 상태 관리 라이브러리가 귀사에 적합한지 잘 모르겠으면 좋겠습니다.
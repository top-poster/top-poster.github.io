---
layout: post
title: "Linux PC에서 자체 호스팅된 GitLab 서버 생성"
author: "Logger"
thumbnail: "undefined"
tags: 
---


![GitLab logo](https://miro.medium.com/max/5000/1*65Nbs8UGpn5Jhw0KcGCpFw.png)

구석에 오래 된 먼지투성이의 컴퓨터가 누군가가 부팅해서 뭔가 멋진 일을 하기만을 기다리고 있나요?

그렇다면 완전히 자체 호스팅된 GitLab 인스턴스를 구축하여 어디에서나 원격 제어가 가능하도록 함으로써 이 오래된 하드웨어를 잘 활용합시다!

# 내용물

이 문서에서 확인할 내용:

이 가이드는 프로덕션 준비 설정의 가이드가 아닙니다! 이것은 간단한 프로젝트로 여러 서비스(예: GitLab CI/CD, GitLab Pages 등)를 테스트할 수 있는 GitLab 서버를 설정하거나 개인 프로그래밍 환경을 방해하기 위해 사용할 수 있습니다.

설치 중에 추가 사항이 있거나 문제가 있으면 코멘트로 알려주십시오!

# 1. GitLab 옴니버스 설치

운영 체제에 따라 설치 프로세스가 달라질 수 있습니다. GitLab에는 지원되는 시스템과 해당 설치 프로세스의 목록이 있습니다.

다음 지침은 Ubuntu 사용자를 위한 것입니다. 기본적으로 GitLab 문서와 동일하지만, 저는 이 문서들을 여기에 넣기로 결정했습니다. 그래서 우리는 모든 과정을 한 곳에 기록했습니다.

먼저 필요한 종속성을 설치해야 합니다.

```undefined
$sudo apt-get 업데이트
$sudo apt-get install-ycurl 열기 서버 ca-certificate tzdata perl
```

메일 서버를 구성하면 GitLab에서 이메일 알림을 보낼 수 있습니다. 이를 위해 Postfix를 사용하거나 외부 SMTP 서버를 구성할 수 있습니다.

이 경우 단순성을 유지하고 Postfix를 설치하고자 합니다.

```undefined
$sudo apt-get instally 후처리
```

Postfix 설치 중에 구성 페이지가 나타납니다. 인터넷 사이트를 선택하고 도메인 이름을 메일 이름으로 사용합니다. 다음 단계에서 GitLab 서버의 하위 도메인을 정의합니다. 이 하위 도메인을 메일 이름(예: `gitlab.mysite.com)`으로 사용합니다.

GitLab 서버(예: `gitlab.mysite.com)`에서 메일을 수신할 때 표시되는 이름입니다.

이제 GitLab 패키지 저장소를 추가할 준비가 되었습니다.

```undefined
$curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.deb.sh | sudo bash
```

## DNS 구성

패키지 설치를 계속하기 전에 공용 인터넷에서 GitLab 인스턴스에 액세스할 수 있도록 DNS를 올바르게 설정해야 합니다. 이를 위해 호스팅 공급자에 하위 도메인을 생성해야 합니다.

사용하는 공급자에 따라 이 단계가 달라질 수 있습니다. 문서에서 가장 일반적인 DNS 레지스터에 대한 자습서를 찾을 수 있습니다.

이 경우 DNS A 레코드를 추가해야 합니다. 즉, 이전에 구성한 메일 이름과 동일한 하위 도메인(예: `gitlab.mysite.com`)이 IP 주소(네트워크의 공용 IP 사용)를 가리킵니다. 포트 포워딩은 다음 단계에서 처리하겠습니다.

## 인증서 및 포트 포워딩을 암호화합니다.

GitLab 외부 URL로 `https://` 주소를 사용하는 경우, 암호화는 자동으로 SSL 인증서를 요청합니다. 이 작업을 수행하려면 포트 80 및 443에 액세스할 수 있는지 확인해야 합니다!

GitLab 서버가 개인 네트워크에 있으므로 서버가 실행 중인 리눅스 PC로 두 포트를 직접 전달해야 합니다. 라우터의 소프트웨어에 따라 포트를 여는 방법이 다를 수 있습니다. 너도 이런 과정이 어떻게 당신의 특정 라우터에서 일하거나 가장 일반적으로 사용되는 라우터들을 위해 일해야 한다 이 참고하라를 찾기 위한 빠른 구글 검색을 할 수 있다.

포트를 컴퓨터의 IP 주소로 전달하기 전에 정적 IP를 이 장치에 할당해야 합니다. IP가 변경되고 라우터가 두 포트를 모두 이전 IP 주소로 전달하면 문제가 발생합니다. DHCP 예약을 사용하여 이 작업을 수행하거나(라우터를 통해 정적 IP를 할당) 장치 자체에서 구성할 수 있습니다.

모든 IP 및 포트 관련 항목을 한 곳에서 쉽게 구성할 수 있고 컴퓨터가 기본 설정으로 유지되기 때문에 라우터에서 DHCP 예약을 사용하여 구성하는 것이 좋습니다.

또한 방화벽이 두 포트 모두에서 트래픽을 허용하는지 확인해야 합니다. Ubuntu를 사용하는 경우 사용할 기본 방화벽은 UFW입니다.

먼저 UFW가 실행 중인지 확인해야 합니다.

```undefined
$suduw 활성화
```

작동 여부 확인:

```undefined
$suw 상태 상세 내역
```

UFW에 HTTP 및 HTTPS 프로토콜을 허용하도록 하려면 다음을 실행해야 합니다.

```undefined
$sudufow allow 80,197
```

또는 다음을 사용할 수 있습니다.

```undefined
$sudufow 허용 http,twitter
```

두 명령 모두 동일한 결과를 얻습니다. 이제 GitLab 패키지를 설치할 준비가 완료되었습니다.

이전에 구성한 하위 도메인으로 `https://gitlab.example.com`을 바꾸면 다음과 같은 작업을 수행할 수 있습니다.

```undefined
$sudo EXTERNAL_URL="https://gitlab.example.com" apt-get install gitlab-ee
```

마지막으로 GitLab 서버를 시작합니다.

```undefined
$suggitlab-ctl 시작
```

일반적으로 GitLab 서버를 처음 방문할 때 루트 암호를 제공해야 합니다. 그렇지 않은 경우(이 문제가 있었습니다) 콘솔을 통해 사용자 암호를 변경하는 방법에 대한 이 가이드를 참조하십시오. 루트 사용자는 ID가 `7`이 아니라 `1`이므로 루트 사용자에 액세스하는 명령은 다음과 같습니다.

```undefined
사용자 = 사용자.여기서(id: 1) 먼저
```

## 문제 해결

이 과정에서 문제가 발생하면 GitLab 옴니버스 공식 설명서를 사용하는 것이 좋습니다. 이 설명서는 실제로 유용하며 다양한 문제에 대한 방대한 양의 문제 해결 옵션이 포함되어 있습니다.

만약 여러분이 네트워크 관련 문제를 다루고 있다면, `텔레넷`과 `tcpdump`라는 도구들이 여러분의 가장 친한 친구들이다! 제게 큰 도움이 된 작은 예:

```undefined
$tcpdump -i < 인터페이스 이름 < 포트 n -n -Q 제외
```

이 명령은 컴퓨터의 특정 인터페이스 및 포트에 대한 모든 들어오고 나가는 트래픽을 표시합니다(`-n`은 이름 확인이 없음을 의미하며, `-Q`는 들어오는 트래픽만 캡처해야 하는지, 나가는 트래픽만 캡처해야 하는지 여부를 지정하는 데 사용됩니다).

예를 들어 SSH를 통해 디바이스에 연결하는 데 문제가 있는 경우(다음 단계에서 설정), `tcpdump` 명령을 사용하여 문제의 루트를 확인할 수 있습니다.

# 2. SSH를 사용하여 서버에 연결

이제 GitLab 인스턴스가 가동되고 실행 중이므로 어디에서나 서버를 관리할 수 있기를 바랍니다. 이를 위해 SSH 연결을 설정합니다.

OpenSSH 서버를 아직 설치하지 않은 경우 다음 단계를 시작하십시오.

```undefined
$sudo apt 업데이트
$sudo apt installsh
```

서버가 실행 중인지 확인합니다.

```undefined
$sudo systemctl 상태 ssh
```

SSH를 통해 서버에 연결하기 전에 해당 단계에 대한 최대 보안을 유지해야 합니다. 이를 위해 다음과 같은 사항을 구성할 것입니다.

먼저 SSH 서버를 `프로토콜 2` 연결만 허용하도록 변경하겠습니다. `/etc/ssh/sshd_config`에서 SSH 구성 파일을 열고 `Protocol 2`를 추가하십시오.

![Configuring SSH Protocol 2](https://miro.medium.com/max/2212/1*ij2QpqJ_wI8p5A2HKlVVlw.png)

또한 기본 SSH 포트인 포트 22를 피해야 하므로 가능한 공격 대상 중 하나가 됩니다. 물론, 무명을 통한 보안은 그리 좋은 방법은 아니지만, 22번 항구를 무작위로 시도하는 사람들을 여전히 힘들게 한다.

이를 위해 위에서 언급한 구성 파일의 SSH 포트를 잘 알려지지 않은 포트 또는 등록된 포트 범위에 있는 포트로 변경합니다(49152-65535 사이의 포트 사용).

또한 우리는 당신이 선택한 포트를 열어야 합니다. 라우터에서 포트 전달 단계를 반복하고 방화벽에서 포트를 엽니다. UFW 사용자의 경우 간단한 `허용` 명령으로 다음과 같은 작업을 수행할 수 있습니다.

```undefined
$suw allow <.
```

최대 보안을 제공하는 마지막 단계는 암호 인증을 완전히 사용하지 않는 것입니다. 암호라는 옵션 검색SSH 구성 파일에서 인증`을 선택하고 값을 `아니오`로 변경합니다.

![Disabling password authentication](https://miro.medium.com/max/2636/1*pt2KGUXD86h1X7Nydid6ug.png)

그런 다음 개인/공용 키 쌍을 만들 것입니다. 이 안내서를 따라 필요에 맞게 조정할 수 있습니다. 또는 간단한 접근 방식을 원할 경우 다음 명령을 사용하십시오.

```undefined
$ssh-keygen -f ~/.know/<br>
```

암호를 제공할지 묻는 메시지가 표시됩니다. 그렇게 하는 것을 추천하고 싶다. 다른 사용자가 개인 키 파일에 액세스할 수 있으면 암호 없이 사용할 수 없게 됩니다.

이제 서버에 키 쌍을 복사합니다.

```undefined
$ssh-copy-id -i < username@@server-IP < 포트
```

username`은 나중에 서버에 로그인할 사용자의 이름입니다. 이렇게 하면 다음 암호를 사용하지 않고도 서버에 연결할 수 있습니다.

```undefined
$ssh <username@< -p < -i <name
```

이제 어디에서나 Linux PC에 연결할 수 있습니다. 좋습니다. GitLab 서버를 언제든지 시작하고 중지할 수 있지만 가상 머신이 아니기 때문입니다. 그것은 당신의 집에 서있는 실제 컴퓨터로 남아있습니다.

컴퓨터가 실행되고 있지 않지만 GitLab 서버를 시작하기 위해 컴퓨터에 액세스하려는 경우 어떻게 해야 합니까? 그러기 위해서는 컴퓨터를 원격으로 시작할 수 있는 기능이 필요합니다.

# 3. 원격으로 컴퓨터 깨우기

우리 프로젝트의 마지막 단계로 넘어가면, 이건 좀 까다로워. WOL(Wake-on-LAN) 기술을 활용해 다른 기기에서 PC를 깨우고 있으며, 이를 더욱 확대해 같은 네트워크에 없어도 PC를 깨울 수 있도록 하겠습니다.

먼저 BIOS 설정에서 WOL을 활성화해야 합니다. BIOS가 조금 오래된 경우에는 이 문제가 상당히 복잡할 수 있습니다. 일반적으로 최신 마더보드는 전원 관리 설정에서 이 옵션을 지원합니다.

특정 마더보드를 위해 WOL을 활성화하는 방법에 대해 알아보는 것이 좋습니다. 제 것은 10년 정도 된 것 같은데, 적당한 장소를 찾기가 좀 어려웠어요. BIOS에서 ErP 옵션을 비활성화해야 한다는 사실을 알게 된 지 한 시간이 넘었습니다.

ERP는 PC가 종료 상태 동안 사용할 수 있는 전력량을 결정합니다. 활성화되면 ErP는 최대 전력 소비량을 1W로 제한합니다. 이 옵션을 사용하지 않도록 설정하면 WOL, PME 웨이크업 이벤트 등의 기능이 활성화됩니다.

자신의 디바이스에 대한 올바른 설정을 찾았으면 NIC(네트워크 인터페이스 카드)에서 WOL을 사용하도록 설정할 수 있습니다. `ethtool`을 사용하여 WOL의 활성화 여부를 확인할 수 있습니다.

```undefined
$ethtool < 인터페이스 이름
```

출력은 다음과 같습니다.

![“ethtool” output](https://miro.medium.com/max/2104/1*jkToa_B1lqDlHLfdV1tCSg.png)

support Wake-on`에서 NIC가 WOL을 지원하는지 여부를 확인할 수 있습니다. 우리는 `g`자를 찾고 있다. 즉, NIC가 마법 패킷을 사용한 웨이크업 기능을 지원합니다.

보시다시피 제 웨이크온 옵션은 이미 g로 설정되어 있습니다. 당신의 것은 아마도 d로 설정될 것입니다. d는 "장애인"을 의미합니다. 그렇다면 WOL을 활성화해야 합니다. 일반적으로 이 작업은 간단한 `ethtool` 명령으로 수행되지만 문제는 재부팅 후 옵션이 재설정된다는 것입니다.

이를 피하기 위해 systemd 파일을 작성해야 한다. wol.service라는 파일을 만들어 /etc/systemd/system에 저장한 후 다음 코드를 복사하여 붙여 넣습니다. 인터페이스 이름을 적절한 이름으로 바꾸는 것을 잊지 마십시오!

이제 `시스템d`가 새로운 스크립트를 인식하도록 합니다.

```undefined
$ systemctl 데몬-daemon-contract
```

서비스 활성화:

```undefined
$ systemctl enablewol.service
```

시작:

```undefined
$ systemctl start wol.service
```

이제 변경 사항을 지속적으로 적용했으며 시스템을 재부팅하면 NIC가 올바르게 구성됩니다!

완료 후 대상 PC로 매직 패킷을 보낼 수 있는 도구가 필요합니다. macOS를 사용하다 보니 간단한 brew install wake onlan이 해줬다. 이제 GitLab 서버를 깨울 수 있습니다(개인 네트워크 내부에서만 가능!).

```undefined
$wakeonlan -i < < mac-address >
```

wakeonlan 도구에는 시작할 장치의 MAC 주소가 필요합니다. 또한 기본적으로 도구가 제대로 작동하려면 브로드캐스트 주소가 필요합니다.

하지만 여전히 두 가지 문제가 있습니다.

## 어디서든지 깨어나는 것

우선, 우리는 매직 패킷이 UDP 프로토콜을 통해 전송된다는 것을 알아야 하므로, UDP 트래픽도 허용하도록 라우터에 포트 포워딩을 구성해야 합니다. SSH 연결을 위해 라우터에서 포트를 이미 열었으므로 웨이크업 시 동일한 포트를 사용할 수 있습니다.

웨이크업용으로 다른 포트를 구성할 수도 있습니다. UDP 프로토콜이 해당 포트에서 허용되는지 확인하십시오.

## 방송 회피하기

그러기 위해서, 우리는 우리의 라우터에서 정적 ARP 항목을 만들어야 합니다. ARP는 주소 확인 프로토콜을 의미하며 IP 주소를 네트워크 장치의 MAC 주소에 연결하는 데 사용됩니다.

정적 ARP 항목은 ARP 캐시의 영구 항목이며, 이는 IP 주소(이전 장치에 대해 선택한 정적 IP)를 Linux PC의 MAC 주소에 영구적으로 바인딩함을 의미합니다.

이 단계는 라우터 유형에 따라 다릅니다. TP-Link 라우터에서 IP를 선택해야 했습니다.

다 됐다! 더 이상 어쩔 수 없다! 이제 다음 명령을 사용하여 다른 네트워크에서 컴퓨터를 시작할 수 있습니다.

```undefined
$wakeonlan -i < 네트워크의 공용 IP public -p p mac-address >
```

## 문제 해결

WOL 구성 중에 문제가 발생할 경우 이전과 같이 `tcpdump`와 같은 도구는 마법 패킷이 대상 PC에 도달하는지 여부를 확인하는 데 유용합니다.

# 4. 모든 것을 결합하는 것

다음은 원하는 곳에서 컴퓨터를 부팅하고 SSH를 통해 연결할 수 있는 간단한 스크립트입니다. 값을 바꾸기만 하면 다음과 같은 작업을 수행할 수 있습니다.

# 다 됐다! 더 이상 어쩔 수 없다!

이 작은 프로젝트를 하면서 새로운 것을 배웠기를 바랍니다. 여러분은 미래에 여러분의 개인용 GitLab 서버를 즐길 것입니다!

읽어주셔서 감사합니다!

# 참고문헌
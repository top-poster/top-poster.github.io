---
layout: post
title: "반응하는 고급 데이터 필터링"
author: "Logger"
thumbnail: "undefined"
tags: 
---


![Dynamic filters](https://miro.medium.com/max/2278/1*YTnEjQsRp71VJtGsQvsL7w.png)

제가 최근에 썼듯이, 우리는 점점 더 많은 데이터를 다루고 있습니다. 이 데이터가 애플리케이션에 입력되면 사용자가 사용할 수 있도록 만들어야 합니다. 오늘은 동적 필터를 생성하는 방법에 대해 살펴보겠습니다. 특정 필터를 사용하거나 사용하지 않도록 설정하면 화면에서 데이터가 즉시 업데이트됩니다.

![Filters on Amazon, Craigslist, and PokerStars.](https://miro.medium.com/max/850/1*RughI-TaCWnQ__fmn9S76w.png)

데모 응용 프로그램의 단순성에 속지 마십시오. 대량의 데이터와 필터를 조합하여 사용할 수 있는 강력한 아키텍처를 구축하겠습니다. 우리의 코드는 유연하고, 역동적이며, 유지관리가 가능할 것이다.

제가 모든 과정을 안내하고, 모든 내용을 설명하도록 하겠습니다.

곧장 뛰어들자!

# 당사의 데이터

The Movie Database에 따르면 현재 가장 인기 있는 60편의 영화에 대한 정보가 포함된 JSON 파일을 사용할 예정입니다. movies.json 파일에 저장한 API의 사용자 지정 응답입니다.

항상 그렇듯이, 우리는 플랫 데이터 구조를 사용합니다. 이와 유사한 구조의 관련 장르(ID와 이름)에 대한 정보를 담은 generes.json 파일이 추가로 있다.

약간의 스타일링이 포함된 전용 컴포넌트로 영화를 제작하면 다음과 같이 보입니다.

![The Movie components](https://miro.medium.com/max/1426/1*I_natw5MZIMd0XUB4BRR2w.png)

보시다시피 제목, 설명의 일부, 개봉일 연도(오른쪽 위 코너), 장르, 영화가 받은 투표수(이 글에서는 사용하지 않는다) 등을 표기한다.

실제 필터링 논리(코드)를 만들기 전에 필터링 데이터 및 부울 식에 대해 몇 마디 말할 수 있습니다.

# 데이터 필터링

![Filters in the top segment.](https://miro.medium.com/max/1426/1*BSpCnwOyBZ_OB8b4l92FrA.png)

우리가 영화 목록을 렌더링할 때, 우리는 컴포넌트의 속성으로 사용할 수 있는 영화를 렌더링하기 위한 데이터를 가지고 있다. 모든 동영상의 데이터 개체가 포함된 배열입니다. 따라서 데이터를 필터링하는 것에 대해 이야기할 때는 기본적으로 이 배열을 사용하기 전에 조작하여 `무비` 구성 요소를 렌더링하는 것에 대해 이야기합니다.

데모 응용 프로그램의 스크린샷에서 볼 수 있듯이 두 그룹의 필터가 있습니다(이론적으로 더 많을 수 있음).

다음과 같은 상태로 필터 관련 데이터를 저장해야 할 수도 있습니다.

제발 이러지 마세요! 제가 설명해 드릴게요. 코드에서 반복 패턴을 볼 때마다(이 경우 years Selected와 genreIds Selected의 `useState` 사용법이 거의 동일) 주의를 기울여야 합니다. 거의 모든 경우에, 더 좋고 더 일반적인 해결책이 있다.

위의 설정이 최선의 방법이 아닌 이유 중 하나는 다음과 같습니다. 여기에는 실제 데이터를 필터링하는 방법에 대한 정보가 포함되어 있지 않습니다. 우리의 `무비` 객체의 어떤 속성이 관련이 있습니까? years Selected의 값(년)은 어떻게 합니까? 그리고 실제로 데이터를 필터링할 수 있는 기능을 어디서 만들까요? 우리가 가지고 있는 두 개의 기능 그룹(년, 장르)은 서로 어떤 관계를 맺고 함께 일하는가?

위의 유사 솔루션은 구조가 부족하고 미래에 대한 준비가 되어 있지 않습니다. 필터 그룹이 더 필요하면 어떻게 하죠? 15개가 필요하면 어떻게 하죠? 우리는 15번의 `국가 사용` 전화를 할 것인가? 네가 처음은 아니겠지만, 그건 반패턴이야. 그것은 장기적으로 문제를 일으킬 것이다.

아래 한 가지 솔루션에 대해 자세히 알아보겠습니다. 그러나 앞에서 언급한 것처럼 부울 식에 대한 간단한 단어입니다. 내 생각에, 당신은 당신의 애플리케이션에서 데이터를 필터링하기 위한 계획을 세우기 전에 이것에 대한 매우 확실한 이해가 필요하다.

![Demo application in action](https://miro.medium.com/max/1426/1*HJ-RLRTd2vrRh-Zg0pX7uw.gif)

# 부울 식

부울 식 또는 논리 식은 `OR`, `AND`, `NOT`와 같은 연산자를 사용합니다. 그들의 자바스크립트 등가물은 `|| ipt`이다.

우리의 두 필터 그룹으로 돌아가보자: 년도와 장르. 다음과 같은 필터를 활성화한다고 가정해 보십시오.

![Filters](https://miro.medium.com/max/1428/1*F0Z_qvBsCsDAGlFIO-3U8w.png)

저희는 2년, 2개의 장르를 선택했습니다. 이것은 무엇을 의미합니까? 그 질문에 대한 답은 생각보다 간단하지 않다. 몇 개 생각해 낼 수 있어요.

다음 영화를 선택하십시오.

부울 연산자의 미묘한 차이점에 유의하십시오. 그들은 모든 차이를 만들어낸다. 개발자로서, 여러분은 이런 선택을 해야 합니다. 필터는 어떻게 작동합니까? 당신이 결정하라. 이 문제는 고객 또는 제품 소유자와 상의해야 하며 최종 사용자가 필터를 사용할 때 어떻게 작동하는지 확인해야 합니다.

마지막으로 여러분과 여러분의 동료들은 여러분 자신의 코드가 어떻게 동작하는지 알아야 합니다. 이렇게 하면 길을 잃기 쉬우므로 여러 필터 그룹을 처리할 수 있는 일반 솔루션을 만들어야 하는 더 큰 이유가 됩니다.

선택하자: 우리는 영화가 선택된 해에 개봉되고 선택된 모든 장르에 속하는 경우 반환한다.

위의 옵션 3입니다.

코드를 쓸 시간입니다.

# 상태의 필터

국가 관리는 그 자체로 주제이다. 항상 여러 가지 해결책이 있습니다. 이 경우 선택한 필터를 추적하기 위해 단일 `useState` 호출을 선택한다.

필터 유형의 개체 배열이 포함되어 있습니다. 각 필터에는 이름, 그룹, 함수의 세 가지 데이터 포인트(속성)가 있습니다.

우리는 우리의 상태를 조작하기 위해 다음과 같은 (감축기) 기능을 가지고 있다.

인터페이스에서 필터 레이블 중 하나를 클릭하면(더 나은 용어가 부족하기 때문에) `토글 필터` 함수를 호출한다. 예를 들어 필터 그룹 "년"에 대한 레이블을 확인할 수 있습니다. 관련 코드는 다음과 같습니다.

이름과 그룹 식별자를 `토글 필터`에 전달하는 방법뿐만 아니라 특정 필터에 대해 동영상을 선택해야 하는지 여부를 결정하는 데 사용할 수 있는 기능도 확인하십시오.

장르 레이블에 대해서도 비슷한 작업을 수행합니다.

이제 우리 주는 영화를 어떻게 걸러내야 하는지에 대해 많은 지식을 가지고 있다. 다음 번에는 꼭 그렇게 합시다.

# 필터 적용

그냥 무릎 위에 코드를 던지는 대신, 각각의 부분을 하나씩 살펴볼 것입니다. 여기서 모든 마술이 일어납니다. 그래서 우리가 그것의 모든 작은 부분들을 이해하도록 노력합시다.

필터를 적용하는 주요 기능:

이 기능은 우리 주의 모든 영화 및 필터를 수신합니다. 충분히 쉬워요. 그런 다음 모든 영화를 반복하고 각 영화에 대해 다음을 확인합니다.

"잠깐만요! 또 똑같은 암호죠, 그렇죠? 그리고 우리는 이런 코드쓰기를 피하도록 노력해야 한다고 일찍이 말했다." 그게 첫 번째 생각이었다면, 당신은 옳은 길을 가고 있어요. 그러나 명료성을 위해 우리는 두 가지 다른 기능을 명시적으로 작성했다.

5번 라인에서는 특정 영화의 결과를 반환합니다. 목록에 표시할 것인지 여부:

```undefined
리턴 쇼 바이연도
```

이 논리 표현에 대한 우리의 선택을 기억하라:

```undefined
(2018년 OR 2017년 개봉) AND (Animation AND Family 장르에 속함)
```

더

이제 `is Show By`라는 도우미 기능을 살펴보겠습니다.Year와 is by General:

현재 선택한 연도를 기준으로 동영상을 상영할지 여부를 결정하기 위해 먼저 상태(라인 2)에서 관련 필터만 선택합니다. 찾을 수 없는 경우 연도가 선택되지 않고 선택한 영화로 간주되는 선택(3행)을 의미합니다. 이 경우 영화를 선택하지 않을 수도 있었다는 점을 언급하는 것이 중요합니다.

마지막 줄(4호선)도 중요한 줄이에요. 연도별 필터를 반복할 때 어레이 방법 `썸`(문서)을 사용하는 방법에 주목하십시오. 통화 중 하나라도 참(예: 영화가 현재 선택된 해에 개봉된 경우)으로 반환되는 경우, 우리는 즉시 참(true)을 반환합니다. 이는 전체 표현에서 `OR` 연산자를 나타냅니다.

```undefined
(2018년 OR 2017년 출시) ...
```

대신 AND 연산자를 사용하려면 Every(문서)를 사용했어야 합니다. 그리고 그것이 바로 다른 도우미 기능인 is Show ByGener에서 우리가 하는 것이다.

여기서 some 대신 every를 어떻게 사용하는지 보세요. 이것은 영화가 예선전을 치르려면 선택된 모든 장르에 속해야 한다는 것을 의미한다. 그리고 그것이 바로 우리가 우리 표현의 두 번째 부분에서 선택한 것입니다.

```undefined
...(Animation AND Family 장르에 속함)
```

# 결론

논리적인(부엉부엉한) 표현에 관해서는, 많은 선택을 해야 한다. 미리 계획이 있는지 확인하세요. 실제 코드를 작성하기 전에 달성하고자 하는 바를 관련자들과 명확히 하십시오.

이 기사에 제시된 솔루션은 완벽하지 않을 수 있지만, 논리와 문제를 확장 가능하고 테스트할 수 있는 일반 솔루션으로 어떻게 정상화할 수 있는지 보여준다.

메모나 다른 캐싱 기술에 대해서는 언급하지 않았습니다. 그것은 단지 요점만 흐트러지게 할 것이기 때문에 일부러 그런 것이다. 따라서 제시된 코드를 더욱 최적화하는 방안을 고려해야 합니다. 특히 데이터 세트가 오늘 살펴본 것보다 훨씬 더 큰 경우에는 더욱 그렇습니다.

JavaScript는 매우 강력합니다. 올바른 기술과 최적화를 통해 매우 많은 양의 데이터와 반복을 처리할 수 있습니다.

시간 내주셔서 감사합니다!

참고: 이 문서에 사용된 모든 코드는 GitLab의 내 리포지토리에서 찾을 수 있습니다.